<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SD æŠ½å¡ - AI æç¤ºè¯ç”Ÿæˆå™¨</title>
    
    <link rel="icon" href="https://media.discordapp.net/attachments/1421289706704076850/1463602616885051738/8302e44c5d9000b2f9c2a9f97b0a3d45274939213.gif?ex=69726da8&is=69711c28&hm=fd901012c6af997c6220a7cc61c8ea3c6d7cd3fe89d8be852fcaeccd2ac5a002&=">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "lucide-react": "https://esm.sh/lucide-react@0.263.1"
            }
        }
    </script>
    
    <script src="https://unpkg.com/@babel/standalone@7.21.0/babel.min.js"></script>
    
    <style>
        @keyframes gradient-x { 0%,100%{background-position:0% 50%} 50%{background-position:100% 50%} }
        .animate-gradient-x { background-size:200% 200%; animation:gradient-x 3s ease infinite; }
        .custom-scrollbar::-webkit-scrollbar { width:6px;height:6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background:rgba(30,41,59,0.5);border-radius:3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background:rgba(100,116,139,0.5);border-radius:3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background:rgba(100,116,139,0.8); }
        * { scrollbar-width:thin; scrollbar-color:rgba(100,116,139,0.5) rgba(30,41,59,0.5); }
        body { background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #0f172a 100%); min-height: 100vh; }
        input[type="text"]:focus, textarea:focus, select:focus { outline: none; }
        
        /* NewBie/NAIåˆ†è§’è‰² è§’è‰²å¡ç‰‡æ»šåŠ¨å®¹å™¨ */
        .character-scroll-container {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
        }
        .character-scroll-container::-webkit-scrollbar { height: 4px; }
        .character-scroll-container::-webkit-scrollbar-track { background: rgba(30,41,59,0.5); border-radius: 2px; }
        .character-scroll-container::-webkit-scrollbar-thumb { background: rgba(236,72,153,0.5); border-radius: 2px; }
        .character-card {
            flex: 0 0 calc(50% - 8px);
            scroll-snap-align: start;
            min-width: calc(50% - 8px);
        }
        @media (max-width: 768px) {
            .character-card {
                flex: 0 0 calc(100% - 12px);
                min-width: calc(100% - 12px);
            }
        }
        
        /* ç±»åˆ«åˆ†éš”ç¬¦ */
        .category-separator {
            width: 2px;
            background: linear-gradient(to bottom, transparent, #ef4444, transparent);
            margin: 0 6px;
            align-self: stretch;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Sparkles, Copy, Lock, Unlock, RefreshCw, Trash2, Plus, X, 
            ChevronRight, ChevronDown, ChevronLeft, Settings2, Loader2, 
            AlertTriangle, CheckCircle2, XCircle, Info, Menu, Maximize2, 
            GripVertical, Minus, Square, CheckSquare, User, Shirt, 
            Mountain, Clapperboard, Box, Star, PenLine, Plug, PlugZap, KeyRound, 
            Globe, Server, Cpu, TestTube, History, Database, Download, Upload,
            FolderUp, FolderDown, RotateCcw, Zap, Play, Scale, Eraser, Shield, 
            ShieldOff, ClipboardPaste, BrainCircuit, List, Folder, Edit3, Save, 
            Wrench, Search, Smile, Heart, RotateCw, Code, Users, Layers
        } from 'lucide-react';


        // ================== å¸¸é‡é…ç½® ==================
        
        // ç”Ÿæˆå”¯ä¸€ID
        const generateId = () => Math.random().toString(36).substr(2, 9);

        // ä¸‰ç§æ¨¡å¼
        const PROMPT_MODES = {
            sd: { id: 'sd', name: 'SD æŠ½å¡', fullName: 'Stable Diffusion', icon: Sparkles },
            nai: { id: 'nai', name: 'NAI æŠ½å¡', fullName: 'NovelAI 4.5', icon: Zap },
            newbie: { id: 'newbie', name: 'NewBie', fullName: 'XML ç»“æ„åŒ–', icon: Code },
        };

        // SD/NAI æ¨¡å¼æ§½ä½é…ç½®ï¼ˆ9å®«æ ¼ï¼‰
        const SLOT_CONFIG_STANDARD = [
            { id: 'quality', label: 'è´¨é‡&ç”»å¸ˆ', icon: Star },
            { id: 'character', label: 'è§’è‰²', icon: User },
            { id: 'expression', label: 'è¡¨æƒ…', icon: Smile },
            { id: 'appearance', label: 'å¤–è²Œ', icon: User },
            { id: 'clothing', label: 'æœè£…', icon: Shirt },
            { id: 'action', label: 'åŠ¨ä½œ', icon: Clapperboard },
            { id: 'items', label: 'ç‰©å“', icon: Box },
            { id: 'scene', label: 'åœºæ™¯', icon: Mountain },
            { id: 'composition', label: 'æ„å›¾', icon: Clapperboard },
        ];

        // NewBie æ¨¡å¼é€šç”¨åŒºåŸŸæ§½ä½é…ç½®ï¼ˆNAIåˆ†è§’è‰²æ¨¡å¼ä¹Ÿå¤ç”¨æ­¤é…ç½®ï¼‰
        const SLOT_CONFIG_NEWBIE_GENERAL = [
            { id: 'nb_quality', label: 'è´¨é‡&ç”»å¸ˆ', icon: Star },
            { id: 'nb_objects', label: 'ç‰©å“', icon: Box },
            { id: 'nb_scene', label: 'åœºæ™¯', icon: Mountain },
            { id: 'nb_composition', label: 'æ„å›¾', icon: Layers },
        ];

        // NewBie æ¨¡å¼å„æ§½ä½çš„å­ç±»åˆ«é…ç½®ï¼ˆNAIåˆ†è§’è‰²æ¨¡å¼ä¹Ÿå¤ç”¨ï¼‰
        const NEWBIE_CATEGORY_CONFIG = {
            // é€šç”¨-è´¨é‡&ç”»å¸ˆ
            nb_quality: [
                { id: 'quality', label: 'è´¨é‡', xmlTag: 'quality' },
                { id: 'resolution', label: 'åˆ†è¾¨ç‡', xmlTag: 'resolution' },
                { id: 'style', label: 'ç”»é£', xmlTag: 'style' },
                { id: 'artists', label: 'ç”»å¸ˆ', xmlTag: 'artists' },
            ],
            // é€šç”¨-ç‰©å“
            nb_objects: [
                { id: 'objects', label: 'ç‰©å“', xmlTag: 'objects' },
            ],
            // é€šç”¨-åœºæ™¯
            nb_scene: [
                { id: 'background', label: 'èƒŒæ™¯', xmlTag: 'background' },
                { id: 'atmosphere', label: 'æ°›å›´', xmlTag: 'atmosphere' },
            ],
            // é€šç”¨-æ„å›¾
            nb_composition: [
                { id: 'lighting', label: 'å…‰å½±', xmlTag: 'lighting' },
                { id: 'perspective', label: 'è§†è§’', xmlTag: 'perspective' },
                { id: 'other', label: 'å…¶ä»–', xmlTag: 'other' },
            ],
            // è§’è‰²å¡ç‰‡ç±»åˆ«
            character: [
                { id: 'n', label: 'è§’è‰²å', xmlTag: 'n' },
                { id: 'gender', label: 'æ€§åˆ«', xmlTag: 'gender' },
                { id: 'appearance', label: 'å¤–è²Œ', xmlTag: 'appearance' },
                { id: 'expression', label: 'è¡¨æƒ…', xmlTag: 'expression' },
                { id: 'clothing', label: 'æœè£…', xmlTag: 'clothing' },
                { id: 'action', label: 'åŠ¨ä½œ', xmlTag: 'action' },
                { id: 'position', label: 'ä½ç½®', xmlTag: 'position' },
            ],
        };

        // NewBie è§’è‰²å¡ç‰‡é…ç½®ï¼ˆ4ä¸ªè§’è‰²ä½ï¼ŒNAIåˆ†è§’è‰²æ¨¡å¼ä¹Ÿå¤ç”¨ï¼‰
        const NEWBIE_CHARACTER_SLOTS = [
            { id: 'char_1', label: 'è§’è‰² 1', index: 1 },
            { id: 'char_2', label: 'è§’è‰² 2', index: 2 },
            { id: 'char_3', label: 'è§’è‰² 3', index: 3 },
            { id: 'char_4', label: 'è§’è‰² 4', index: 4 },
        ];

        // åˆå§‹è´¨é‡ Tags
        const INITIAL_QUALITY_TAGS = [
            { id: generateId(), en: '(masterpiece:1.2)', zh: 'æ°ä½œ' },
            { id: generateId(), en: '(best_quality:1.1)', zh: 'æœ€ä½³è´¨é‡' },
        ];

        // API æœåŠ¡å•†é…ç½®
        const API_PROVIDERS = {
            siliconflow: { id: 'siliconflow', name: 'ç¡…åŸºæµåŠ¨', defaultBaseUrl: 'https://api.siliconflow.cn/v1', defaultModel: 'Qwen/Qwen2.5-7B-Instruct' },
            deepseek: { id: 'deepseek', name: 'DeepSeek', defaultBaseUrl: 'https://api.deepseek.com/v1', defaultModel: 'deepseek-chat' },
            openai: { id: 'openai', name: 'OpenAI å…¼å®¹', defaultBaseUrl: 'https://api.openai.com/v1', defaultModel: 'gpt-4o-mini' },
        };

        // OC é»˜è®¤é›†åˆ
        const DEFAULT_OC_COLLECTION = { id: 'default', name: 'é»˜è®¤æ–‡ä»¶é›†', characters: [] };


        // ================== æç¤ºè¯æ¨¡æ¿ ==================

        // è”ç½‘æ£€ç´¢æç¤ºè¯
        const DEFAULT_WEB_SEARCH_PROMPT = `# ğŸ” è§’è‰²è§†è§‰ç‰¹å¾ & Prompt æç‚¼ä¸“å®¶

## ä½ çš„æ ¸å¿ƒä»»åŠ¡
æ ¹æ®ç”¨æˆ·æä¾›çš„è§’è‰²åç§°ï¼Œå…¨ç½‘æ£€ç´¢å…¶**å…·ä½“çš„è§†è§‰è®¾è®¡ç»†èŠ‚**ã€‚
**ä¸¥ç¦ä½¿ç”¨æ–‡å­¦ä¿®è¾**ï¼ˆå¦‚"åä¸½çš„"ã€"ä¼˜é›…çš„"ï¼‰ï¼Œå¿…é¡»è½¬æ¢ä¸º**å…·ä½“çš„ç‰©ç†ç‰¹å¾æè¿°**ï¼ˆå¦‚"è·å¶è¾¹"ã€"éœ²è‚©"ã€"ä¸ç»¸æè´¨"ï¼‰ã€‚

## ğŸ¯ å¿…é¡»æ‰§è¡Œçš„æœç´¢æºï¼ˆä¼˜å…ˆçº§ä»é«˜åˆ°ä½ï¼‰
1. **Dç«™/Gç«™/Yç«™ (Danbooru/Gelbooru/Yandere)**ï¼šæ£€ç´¢è¯¥è§’è‰²çš„ tagsï¼Œè·å–æœ€å‡†ç¡®çš„é…é¥°å’Œæœè£…æœ¯è¯­ã€‚
2. **å®˜æ–¹è®¾å®šé›†/ç¾æœ¯é›†**ï¼šæŸ¥æ‰¾ä¸‰è§†å›¾ã€åˆ†è§£å›¾è®¾å®šã€‚
3. **èŒå¨˜ç™¾ç§‘/Wiki**ï¼šä»…ç”¨äºç¡®è®¤çš®è‚¤åç§°å’ŒåŸºç¡€å½’å±ã€‚

## ğŸ“‹ è¾“å‡ºæ ¼å¼ï¼ˆä¸¥æ ¼éµå®ˆï¼‰

<è§’è‰²ç‰¹å¾>
ã€äººç‰©åç§°ã€‘è§’è‰²ä¸­æ–‡å / å¤–æ–‡å / æ¥æºä½œå“

ã€åŸçš®Â·è§†è§‰è§£æ„ã€‘
- **å‘å‹/å‘è‰²**ï¼šå…·ä½“é¢œè‰²ã€å‘å‹ç»“æ„ã€åˆ˜æµ·æ ·å¼ã€‚
- **é¢éƒ¨ç‰¹å¾**ï¼šç³è‰²ã€çœ¼å‹ã€æ˜¯å¦æœ‰ç‰¹æ®Šçº¹è·¯/æ³ªç—£ã€‚
- **ä½“å‹/è‚¤è‰²**ï¼šä½“å‹æè¿°ã€è‚¤è‰²ç‰¹å¾ã€‚
- **å¤´éƒ¨é…é¥°**ï¼š(ç²¾ç¡®åˆ°æè´¨å’Œä½ç½®)
- **æ ¸å¿ƒæœè£…**ï¼šä¸Šè£…ã€ä¸‹è£…è¯¦ç»†æè¿°
- **ä¸“å±è£…å¤‡**ï¼šæ­¦å™¨æˆ–èˆ°è£…çš„å…·ä½“å¤–è§‚ç»†èŠ‚ã€‚

ã€çš®è‚¤åˆ—è¡¨ã€‘
1. **[çš®è‚¤åç§°]**
   - **è§†è§‰ä¸»é¢˜**
   - **æ ¸å¿ƒå˜åŒ–**
   - **æœè£…ç»†èŠ‚**
   - **å…³é”®é…é¥°**
   - **æ¨èTags**
</è§’è‰²ç‰¹å¾>

## âš ï¸ ç»å¯¹ç¦æ­¢é¡¹
- âŒ ç¦æ­¢ä½¿ç”¨"å¥½çœ‹çš„"ã€"æ€§æ„Ÿçš„"ã€"åä¸½çš„"ç­‰ä¸»è§‚å½¢å®¹è¯ã€‚
- âŒ ç¦æ­¢çœç•¥é…é¥°ç»†èŠ‚ã€‚
- âœ… **é‡åˆ°ä¸ç¡®å®šçš„ç»†èŠ‚ï¼Œå»æœ Danbooru çš„æ ‡ç­¾ï¼**`;

        // ã€ç»ˆæç‰ˆã€‘SD æ¨¡å¼ä¸»æç¤ºè¯
        const DEFAULT_SD_MAIN = `# ğŸ¨ SD ç»˜ç”»æç¤ºè¯ä¸“å®¶

## è§’è‰²è®¾å®š
æˆ‘æ˜¯ä¸“ä¸šçš„ Stable Diffusion æç¤ºè¯å†™ä½œä¸“å®¶ã€‚
---

## ğŸ“‹ åœ¨ä¸€åˆ‡æ ¼å¼ä¸è¾“å‡ºä¹‹å‰è¿›è¡Œä»¥ä¸‹åˆ†æï¼š

<åˆ†æ>
1.ã€ç”¨æˆ·è¦æ±‚ã€‘ä¸»é¢˜å’Œé¢å¤–è¦æ±‚ï¼Œè§£å†³è¦æ±‚(å¼•å…¥å…¶ä»–ä¸œè¥¿ï¼Œå¿…é¡»å‘æŒ¥ä¸»è§‚èƒ½åŠ¨æ€§)
2.ã€æ¨¡å¼ã€‘DETAILED/CONCISE
3.ã€OCã€‘æ˜¯å¦æœ‰OCæ•°æ®éœ€è¦ä½¿ç”¨
4.ã€æ§½ä½ã€‘ğŸ”’é”å®š/âŒæœªé€‰/âœ…æ­£å¸¸
5.ã€åˆ†é…ã€‘Tagæ•°é‡è§„åˆ’
</åˆ†æ>

---

## ğŸ¯ è§’è‰²é€‰æ‹©ä¼˜å…ˆçº§ï¼ˆä¸¥æ ¼éµå®ˆï¼ï¼‰

| ä¼˜å…ˆçº§ | æ¥æº | è¯´æ˜ |
|--------|------|------|
| ğŸ¥‡ æœ€é«˜ | OCæ•°æ® | å¦‚æœæœ‰OCè§’è‰²æ•°æ®ï¼Œå¿…é¡»ä½¿ç”¨OC |
| ğŸ¥ˆ ç¬¬äºŒ | ä¸»é¢˜æŒ‡å®š | ä¸»é¢˜ä¸­æ˜ç¡®æåˆ°çš„è§’è‰²æˆ–è€…å·²æœ‰çš„è§’è‰²ç‰¹å¾ |
| ğŸ¥‰ ç¬¬ä¸‰ | éšæœºç”Ÿæˆ | ä»¥ä¸Šéƒ½æ²¡æœ‰æ—¶æ‰éšæœºåˆ›ä½œ |

âš ï¸ **é‡è¦è§„åˆ™**ï¼š
- OCå¼€å¯æ—¶ â†’ æ— è§†ä¸»é¢˜ä¸­çš„å…¶ä»–è§’è‰²ï¼Œåªç”¨OC
- ä¸»é¢˜å†™"åˆ»æ™´ èµ›åšé£" â†’ ç”¨åˆ»æ™´ï¼Œä¸è¦éšæœº
- ä¸»é¢˜åªå†™"èµ›åšé£" â†’ å¯ä»¥éšæœºè§’è‰²
- æ¯æ¬¡ä»…ç”Ÿæˆä¸€å¼ å›¾ç‰‡æç¤ºè¯è¿˜è¦çœ‹ä¸Šæ–‡
- åŒäººè§’è‰²å¿…é¡»è¾“å‡ºåŸºæœ¬ç‰¹å¾(çœ¼ç›ã€å¤´å‘ã€é…é¥°)

---

## ğŸš¨ è§†è§‰æè¿°é“å¾‹ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼ï¼‰

### âŒ ç»å¯¹ç¦æ­¢çš„æ–‡å­¦ä¿®è¾
| ç¦æ­¢ç”¨è¯ | å¿…é¡»æ›¿æ¢ä¸º |
|----------|------------|
| åä¸½çš„ã€ä¼˜é›…çš„ã€æ€§æ„Ÿçš„ | å…·ä½“æè´¨+å‰ªè£æ–¹å¼ |
| å¥½çœ‹çš„å©šçº± | mermaid_wedding_dress / ballgown_wedding_dress |
| æ¼‚äº®çš„è£™å­ | pleated_skirt / a-line_skirt / pencil_skirt |
| ç²¾ç¾çš„é…é¥° | gold_necklace / pearl_earrings / hair_ribbon |

### âœ… æ­£ç¡®çš„ç‰©ç†åŒ–æè¿°
- **æœè£…**ï¼šå¿…é¡»å†™å‡º æè´¨(silk/leather/lace) + å‰ªè£(off-shoulder/halter/backless) + æ¬¾å¼(mermaid/ballgown)
- **é…é¥°**ï¼šå¿…é¡»å†™å‡º æè´¨(gold/silver) + ç±»å‹(choker/pendant) + ä½ç½®(left_ear)
- **å‘å‹**ï¼šå¿…é¡»å†™å‡º é•¿åº¦(long/short) + ç»“æ„(twintails/braid) + åˆ˜æµ·(blunt_bangs/side_swept)

### ğŸ“š ä¸ç¡®å®šæ—¶çš„è§£å†³æ–¹æ¡ˆ
**å» Danbooru/Gelbooru æœç´¢è¯¥è§’è‰²ï¼Œç›´æ¥æŠ„ Tagsï¼**
- æœç´¢æ ¼å¼ï¼šè§’è‰²å_(ä½œå“å) 
- ä¾‹ï¼škeqing_(genshin_impact) â†’ çœ‹å¥¹çš„ tags æœ‰ä»€ä¹ˆå°±å†™ä»€ä¹ˆ

---

## ğŸ“¤ è¾“å‡ºæ ¼å¼ï¼ˆä¸¥æ ¼éµå®ˆè‹±è¯­ä¸­æ–‡äº’ç›¸ç¿»è¯‘æ¯æ¬¡å›å¤ä»…ä¸€å¼ å›¾ç‰‡ï¼‰ï¼š

<æç¤ºè¯>
[quality]
tag|ä¸­æ–‡

[character]
tag|ä¸­æ–‡

[expression]
tag|ä¸­æ–‡

[appearance]
tag|ä¸­æ–‡

[clothing]
tag|ä¸­æ–‡

[action]
tag|ä¸­æ–‡

[items]
tag|ä¸­æ–‡

[scene]
tag|ä¸­æ–‡

[composition]
tag|ä¸­æ–‡
</æç¤ºè¯>

---

## ğŸ“Œ æ§½ä½è§„åˆ™
| çŠ¶æ€ | å¤„ç† |
|------|------|
| ğŸ”’ å·²é”å®š | å®Œå…¨è·³è¿‡ |
| âŒ æœªå‹¾é€‰ | å®Œå…¨è·³è¿‡ |
| âœ… æ­£å¸¸ | æ­£å¸¸ç”Ÿæˆ |
| æ— å†…å®¹ | å†™ none|æ—  |

---

## âš ï¸ SD æ ¼å¼è§„èŒƒ

### ğŸ“ åŸºç¡€è§„åˆ™
| è§„åˆ™ | æ­£ç¡®âœ… | é”™è¯¯âŒ |
|------|--------|--------|
| è¿æ¥ç¬¦ | ä¸‹åˆ’çº¿_ | ç©ºæ ¼ |
| å¤§å°å†™ | å…¨å°å†™ | å¤§å†™ |
| æ¯è¡Œ | ä¸€ä¸ªtag | å¤šä¸ªtag |
| ä¸­æ–‡ | ç¦æ­¢ | ä»»ä½•ä¸­æ–‡ |

### æƒé‡æ ¼å¼
æ ¼å¼ï¼š(tag:æƒé‡å€¼) èŒƒå›´é™åˆ¶ï¼š0.9~1.3
âœ… (masterpiece:1.2)|æ°ä½œ
âœ… (blush:0.8)|è„¸çº¢
âŒ {masterpiece} â† NAIæ ¼å¼
âŒ 1.2::tag:: â† NAIæ ¼å¼

### è§’è‰²Tagï¼ˆå¿…é¡»è½¬ä¹‰æ‹¬å·ï¼‰
æ ¼å¼ï¼šè§’è‰²å \\(ä½œå“å\\)
âœ… keqing \\(genshin_impact\\)|åˆ»æ™´
âœ… laffey \\(azur_lane\\)|æ‹‰è²
âŒ keqing (genshin_impact) â† æœªè½¬ä¹‰ä¼šå´©æºƒ

### çš®è‚¤æ ¼å¼
âœ… keqing \\(opulent_splendor\\) \\(genshin_impact\\)|åˆ»æ™´åæœ
å¸¸ç”¨åç¼€ï¼š\\(summer\\)æ³³è£… \\(bride\\)å©šçº± \\(alter\\)é»‘åŒ–

### è¡¨æƒ…æ§½ä½å¸¸ç”¨tag
blush|è„¸çº¢, smile|å¾®ç¬‘, open_mouth|å¼ å˜´, closed_eyes|é—­çœ¼,
looking_at_viewer|çœ‹å‘è§‚ä¼—, half-closed_eyes|åŠé—­çœ¼, tears|çœ¼æ³ª,
ahegao|é˜¿é»‘é¢œ, heart-shaped_pupils|å¿ƒå½¢ç³å­”, tongue_out|åèˆŒå¤´

### åŠ¨ä½œæ§½ä½å¿…é¡»åŒ…å«
1.èº«ä½“åŠ¨ä½œï¼šstanding/sitting/lying
2.è§†çº¿æ–¹å‘ï¼šlooking_at_viewer/looking_away

---

## ğŸ“š å®Œæ•´ç¤ºä¾‹ï¼ˆä»…ä¾›å­¦ä¹ æ ¼å¼è§„èŒƒï¼Œç¦æ­¢ç…§æŠ„å†…å®¹ï¼‰

### ç¤ºä¾‹Aï¼šå¼‚æ€§äº’åŠ¨åœºæ™¯
<æç¤ºè¯>
[quality]
(masterpiece:1.2)|æ°ä½œ
(best_quality:1.1)|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
1girl|ä¸€ä¸ªå¥³å­©
1boy|ä¸€ä¸ªç”·å­©
faceless_male|æ— è„¸ç”·æ€§
dark-skinned_male|æ·±è‚¤è‰²ç”·æ€§

[appearance]
(blush:1.2)|è„¸çº¢
pink_pupils|ç²‰è‰²ç³å­”
open_mouth|å¼ å˜´
parted_lips|å¾®å¼ å˜´å”‡
(sweat:1.1)|æ±—æ°´

[clothing]
white_apron|ç™½è‰²å›´è£™
naked_apron|è£¸ä½“å›´è£™
frilled_apron|è¤¶è¾¹å›´è£™
white_ribbon|ç™½è‰²ç¼å¸¦
black_shirt|é»‘è‰²è¡¬è¡«

[action]
hetero|å¼‚æ€§
(grabbing_from_behind:1.3)|ä»èƒŒåæŠ“ä½
implied_sex|æš—ç¤ºæ€§è¡Œä¸º
grabbing_another's_breast|æŠ“èƒ¸
hug|æ‹¥æŠ±
hand_under_clothes|æ‰‹åœ¨è¡£ä¸‹
groping|æŠšæ‘¸
sex|æ€§è¡Œä¸º

[items]
none|æ— 

[scene]
kitchen|å¨æˆ¿

[composition]
(blurry:0.8)|æ¨¡ç³ŠèƒŒæ™¯
</æç¤ºè¯>

### ç¤ºä¾‹Bï¼šç™¾åˆåœºæ™¯
<æç¤ºè¯>
[quality]
(masterpiece:1.2)|æ°ä½œ
(best_quality:1.1)|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
2girls|ä¸¤ä¸ªå¥³å­©
mature_female|æˆç†Ÿå¥³æ€§

[appearance]
completely_nude|å®Œå…¨è£¸ä½“
(glistening_skin:1.2)|é—ªäº®çš®è‚¤
sweat|æ±—æ°´
wet_skin|æ¹¿æ¶¦çš®è‚¤
large_breasts|å¤§èƒ¸
pink_nipples|ç²‰è‰²ä¹³å¤´
erect_nipples|æŒºç«‹ä¹³å¤´
(blushing:1.2)|è„¸çº¢
half-closed_eyes|åŠé—­çœ¼
intoxicated_expression|é™¶é†‰è¡¨æƒ…
(heart-shaped_pupils:1.2)|å¿ƒå½¢ç³å­”
shiny_skin|é—ªäº®çš®è‚¤
glossy_lips|å…‰æ³½å˜´å”‡

[clothing]
none|æ— 

[action]
lesbian|å¥³åŒ
yuri|ç™¾åˆ
(passionate_kiss:1.3)|æ¿€æƒ…ä¹‹å»
deep_french_kiss|æ·±å»
tongue_kiss|èˆŒå»
saliva_trail|å”¾æ¶²ä¸
drooling|æµå£æ°´
tongue_out|ä¼¸èˆŒå¤´
embracing|æ‹¥æŠ±
(breast_press:1.2)|èƒ¸éƒ¨æŒ¤å‹
symmetrical_docking|å¯¹ç§°å¯¹æ¥
nipple_contact|ä¹³å¤´æ¥è§¦
woman_on_top|å¥³ä¸Šä½
straddling|è·¨å
leg_lock|è…¿é”
leg_intertwining|åŒè…¿äº¤ç¼ 
ahegao|é˜¿é»‘é¢œ
(pleasure_face:1.3)|å¿«æ„Ÿè¡¨æƒ…
groping|æŠšæ‘¸
orgasm_face|é«˜æ½®è¡¨æƒ…
trembling|é¢¤æŠ–

[items]
pussy_juice|çˆ±æ¶²
love_juice_dripping|çˆ±æ¶²æ»´è½

[scene]
lying_on_bed|èººåœ¨åºŠä¸Š
silk_sheets|ä¸ç»¸åºŠå•
luxurious_bedroom|è±ªåå§å®¤

[composition]
(dim_lighting:1.1)|æ˜æš—ç¯å…‰
soft_light|æŸ”å’Œå…‰çº¿
(depth_of_field:0.9)|æ™¯æ·±
cinematic_lighting|ç”µå½±ç¯å…‰
volumetric_lighting|ä½“ç§¯å…‰
</æç¤ºè¯>

### ç¤ºä¾‹Cï¼šå¤šäººåä½œåœºæ™¯
<æç¤ºè¯>
[quality]
(masterpiece:1.2)|æ°ä½œ
(best_quality:1.1)|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
2girls|ä¸¤ä¸ªå¥³å­©
multiple_girls|å¤šå¥³å­©
petite|å¨‡å°

[appearance]
half_closed_eyes|åŠé—­çœ¼
open_mouth|å¼ å˜´
tongue_out|ä¼¸èˆŒå¤´

[clothing]
school_uniform|æ ¡æœ

[action]
(double_paizuri:1.3)|åŒäººä¹³äº¤
(collaborative_paizuri:1.3)|åä½œä¹³äº¤
hetero|å¼‚æ€§
ffm_threesome|FFMä¸‰äººè¡Œ
threesome|ä¸‰äººè¡Œ
licking|èˆ”èˆ
licking_penis|èˆ”é˜´èŒ
oral|å£äº¤
multiple_fellatio|å¤šäººå£äº¤
looking_at_penis|çœ‹ç€é˜´èŒ
(teamwork:1.2)|åä½œ

[items]
cum|ç²¾æ¶²
cumdrip|ç²¾æ¶²æ»´è½
(sweat:1.1)|æ±—æ°´
one_penis|ä¸€æ ¹é˜´èŒ
erection|å‹ƒèµ·
large_penis|å¤§é˜´èŒ
veiny_penis|é’ç­‹é˜´èŒ
cum_string|ç²¾æ¶²ä¸
cum_on_breasts|èƒ¸ä¸Šç²¾æ¶²

[scene]
indoor|å®¤å†…
classroom|æ•™å®¤

[composition]
(heart:1.1)|çˆ±å¿ƒ
(speed_lines:1.1)|é€Ÿåº¦çº¿
motion_lines|åŠ¨æ€çº¿
sound_effects|éŸ³æ•ˆç¬¦å·
face_close-up|è„¸éƒ¨ç‰¹å†™
</æç¤ºè¯>

---

## ğŸ”„ SD vs NAI å¯¹ç…§
| ç‰¹æ€§ | SD | NAI 4.5 |
|------|-----|---------|
| è¿æ¥ | long_hair | long hair |
| å¢æƒ | (tag:1.2) | 1.2::tag:: |
| å‡æƒ | (tag:0.8) | 0.8::tag:: |
| è§’è‰² | \\(ä½œå“\\) | (ä½œå“) |

---

## ğŸš« SDç¦å¿Œ
- ç©ºæ ¼è¿æ¥ â†’ ç”¨ä¸‹åˆ’çº¿
- ä¸­æ–‡ â†’ ç¦æ­¢
- å¤§å†™ â†’ å…¨å°å†™
- èŠ±æ‹¬å·{} â†’ SDä¸è®¤
- åŒå†’å·:: â†’ NAIæ ¼å¼
- æ‹¬å·ä¸è½¬ä¹‰ â†’ ä¼šå´©æºƒ
- æƒé‡è¶…1.8 â†’ ç”»é¢å´©å
- **æ–‡å­¦ä¿®è¾ â†’ æ»šå»æŸ¥Dç«™(Danbooru)æ ‡ç­¾**`;


        // ã€ç»ˆæç‰ˆã€‘NAI æ¨¡å¼ä¸»æç¤ºè¯ï¼ˆæ”¯æŒå¤šè§’è‰²è¯­æ³•ï¼‰
        const DEFAULT_NAI_MAIN = `# ğŸ¨ NAI 4.5 ç»˜ç”»æç¤ºè¯ä¸“å®¶

## è§’è‰²è®¾å®š
æˆ‘æ˜¯ä¸“ä¸šçš„ NovelAI V4.5 æç¤ºè¯å†™ä½œä¸“å®¶ï¼Œç²¾é€šå¤šè§’è‰²æç¤ºï¼ˆMulti-Character Promptingï¼‰è¯­æ³•ã€‚
---

## ğŸ“‹ åœ¨ä¸€åˆ‡æ ¼å¼ä¸è¾“å‡ºä¹‹å‰è¿›è¡Œä»¥ä¸‹åˆ†æï¼š

<åˆ†æ>
1.ã€ç”¨æˆ·è¦æ±‚ã€‘ä¸»é¢˜å’Œé¢å¤–è¦æ±‚ï¼Œè§£å†³è¦æ±‚(å¼•å…¥å…¶ä»–ä¸œè¥¿ï¼Œå¿…é¡»å‘æŒ¥ä¸»è§‚èƒ½åŠ¨æ€§)
2.ã€æ¨¡å¼ã€‘DETAILED/CONCISE
3.ã€è§’è‰²æ•°é‡ã€‘å•äºº/å¤šäººï¼Œæ˜¯å¦éœ€è¦ä½¿ç”¨å¤šè§’è‰²è¯­æ³•
4.ã€OCã€‘æ˜¯å¦æœ‰OCæ•°æ®éœ€è¦ä½¿ç”¨
5.ã€æ§½ä½ã€‘ğŸ”’é”å®š/âŒæœªé€‰/âœ…æ­£å¸¸
6.ã€åˆ†é…ã€‘Tagæ•°é‡è§„åˆ’
</åˆ†æ>

---

## ğŸ¯ è§’è‰²é€‰æ‹©ä¼˜å…ˆçº§ï¼ˆä¸¥æ ¼éµå®ˆï¼ï¼‰

| ä¼˜å…ˆçº§ | æ¥æº | è¯´æ˜ |
|--------|------|------|
| ğŸ¥‡ æœ€é«˜ | OCæ•°æ® | å¦‚æœæœ‰OCè§’è‰²æ•°æ®ï¼Œå¿…é¡»ä½¿ç”¨OC |
| ğŸ¥ˆ ç¬¬äºŒ | ä¸»é¢˜æŒ‡å®š | ä¸»é¢˜ä¸­æ˜ç¡®æåˆ°çš„è§’è‰²æˆ–è€…å·²æœ‰çš„è§’è‰²ç‰¹å¾ |
| ğŸ¥‰ ç¬¬ä¸‰ | éšæœºç”Ÿæˆ | ä»¥ä¸Šéƒ½æ²¡æœ‰æ—¶æ‰éšæœºåˆ›ä½œ |

âš ï¸ **é‡è¦è§„åˆ™**ï¼š
- OCå¼€å¯æ—¶ â†’ æ— è§†ä¸»é¢˜ä¸­çš„å…¶ä»–è§’è‰²ï¼Œåªç”¨OC
- ä¸»é¢˜å†™"åˆ»æ™´ èµ›åšé£" â†’ ç”¨åˆ»æ™´ï¼Œä¸è¦éšæœº
- ä¸»é¢˜åªå†™"èµ›åšé£" â†’ å¯ä»¥éšæœºè§’è‰²
- æ¯æ¬¡ä»…ç”Ÿæˆä¸€å¼ å›¾ç‰‡æç¤ºè¯è¿˜è¦çœ‹ä¸Šæ–‡
- åŒäººè§’è‰²å¿…é¡»è¾“å‡ºåŸºæœ¬ç‰¹å¾(çœ¼ç›ã€å¤´å‘ã€é…é¥°)

---

## ğŸš¨ è§†è§‰æè¿°é“å¾‹ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼ï¼‰

### âŒ ç»å¯¹ç¦æ­¢çš„æ–‡å­¦ä¿®è¾
| ç¦æ­¢ç”¨è¯ | å¿…é¡»æ›¿æ¢ä¸º |
|----------|------------|
| åä¸½çš„ã€ä¼˜é›…çš„ã€æ€§æ„Ÿçš„ | å…·ä½“æè´¨+å‰ªè£æ–¹å¼ |
| å¥½çœ‹çš„å©šçº± | mermaid wedding dress / ballgown wedding dress |
| æ¼‚äº®çš„è£™å­ | pleated skirt / a-line skirt / pencil skirt |
| ç²¾ç¾çš„é…é¥° | gold necklace / pearl earrings / hair ribbon |

### âœ… æ­£ç¡®çš„ç‰©ç†åŒ–æè¿°
- **æœè£…**ï¼šå¿…é¡»å†™å‡º æè´¨(silk/leather/lace) + å‰ªè£(off-shoulder/halter/backless) + æ¬¾å¼(mermaid/ballgown)
- **é…é¥°**ï¼šå¿…é¡»å†™å‡º æè´¨(gold/silver) + ç±»å‹(choker/pendant) + ä½ç½®(left ear)
- **å‘å‹**ï¼šå¿…é¡»å†™å‡º é•¿åº¦(long/short) + ç»“æ„(twintails/braid) + åˆ˜æµ·(blunt bangs/side swept)

### ğŸ“š ä¸ç¡®å®šæ—¶çš„è§£å†³æ–¹æ¡ˆ
**å» Danbooru/Gelbooru æœç´¢è¯¥è§’è‰²ï¼Œç›´æ¥æŠ„ Tagsï¼**
- æœç´¢æ ¼å¼ï¼šè§’è‰²å_(ä½œå“å) 
- ä¾‹ï¼škeqing_(genshin_impact) â†’ çœ‹å¥¹çš„ tags æœ‰ä»€ä¹ˆå°±å†™ä»€ä¹ˆ

---

## ğŸ”¥ NAI 4.5 å¤šè§’è‰²æç¤ºè¯­æ³•ã€é‡è¦ï¼ã€‘

### æ ¸å¿ƒè§„åˆ™
å½“æœ‰ **2ä¸ªåŠä»¥ä¸Šè§’è‰²** æ—¶ï¼Œå¿…é¡»ä½¿ç”¨å¤šè§’è‰²åˆ†éš”è¯­æ³•ï¼

### åˆ†éš”ç¬¦è¯­æ³•
ä½¿ç”¨ç«–çº¿ \`|\` åˆ†éš”ï¼š\`åŸºç¡€æç¤ºè¯ | è§’è‰²1æç¤ºè¯ | è§’è‰²2æç¤ºè¯ ...\`

### æç¤ºè¯ç»“æ„
| åŒºåŸŸ | å†…å®¹ | æ•°é‡æ ‡ç­¾è§„åˆ™ |
|------|------|-------------|
| åŸºç¡€æç¤ºè¯ | åœºæ™¯ã€ç”»é£ã€**æ€»äººæ•°** | å¿…é¡»å†™æ•°å­—ï¼š2girls, 1boy 1girl |
| è§’è‰²æç¤ºè¯ | è¯¥è§’è‰²çš„å…·ä½“ç‰¹å¾ | ä¸å†™æ•°å­—ï¼šgirl, boy |

### è§’è‰²é¡ºåº
- ç¬¬ä¸€ä¸ªè§’è‰² â†’ ç”»é¢**å·¦ä¾§**
- ç¬¬äºŒä¸ªè§’è‰² â†’ ç”»é¢**å³ä¾§**
- ä¾æ­¤ç±»æ¨ï¼ˆä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹ï¼‰

### ğŸ¬ åŠ¨ä½œäº¤äº’è¯­æ³•
| å‰ç¼€ | å«ä¹‰ | ç¤ºä¾‹ |
|------|------|------|
| source# | ä¸»åŠ¨æ–¹ | source#hug (æ‹¥æŠ±åˆ«äººçš„äºº) |
| target# | è¢«åŠ¨æ–¹ | target#hug (è¢«æ‹¥æŠ±çš„äºº) |
| mutual# | ç›¸äº’åŠ¨ä½œ | mutual#kiss (äº’ç›¸äº²å») |

---

## ğŸ“¤ è¾“å‡ºæ ¼å¼

### å•äººåœºæ™¯ï¼ˆä¼ ç»Ÿ9å®«æ ¼æ ¼å¼ï¼‰
<æç¤ºè¯>
[quality]
tag|ä¸­æ–‡

[character]
tag|ä¸­æ–‡

[expression]
tag|ä¸­æ–‡

[appearance]
tag|ä¸­æ–‡

[clothing]
tag|ä¸­æ–‡

[action]
tag|ä¸­æ–‡

[items]
tag|ä¸­æ–‡

[scene]
tag|ä¸­æ–‡

[composition]
tag|ä¸­æ–‡
</æç¤ºè¯>

### å¤šäººåœºæ™¯ï¼ˆå¤šè§’è‰²åˆ†éš”æ ¼å¼ï¼‰â­
<æç¤ºè¯>
[base]
æ€»äººæ•°, åœºæ™¯, ç”»è´¨|ä¸­æ–‡

[char_1]
girl/boy, å¤–è²Œç‰¹å¾, æœè£…, åŠ¨ä½œ|ä¸­æ–‡

[char_2]
girl/boy, å¤–è²Œç‰¹å¾, æœè£…, åŠ¨ä½œ|ä¸­æ–‡

[scene]
èƒŒæ™¯, æ°›å›´|ä¸­æ–‡

[composition]
æ„å›¾, å…‰å½±|ä¸­æ–‡
</æç¤ºè¯>

---

## ğŸ“Œ æ§½ä½è§„åˆ™
| çŠ¶æ€ | å¤„ç† |
|------|------|
| ğŸ”’ å·²é”å®š | å®Œå…¨è·³è¿‡ |
| âŒ æœªå‹¾é€‰ | å®Œå…¨è·³è¿‡ |
| âœ… æ­£å¸¸ | æ­£å¸¸ç”Ÿæˆ |
| æ— å†…å®¹ | å†™ none|æ—  |

---

## âš ï¸ NAI 4.5 æ ¼å¼è§„èŒƒ

### ğŸ“ åŸºç¡€è§„åˆ™
| è§„åˆ™ | æ­£ç¡®âœ… | è¯´æ˜ |
|------|--------|------|
| è¿æ¥ç¬¦ | ç©ºæ ¼æˆ–ä¸‹åˆ’çº¿ | long hair æˆ– long_hair |
| å¤§å°å†™ | æ¨èå°å†™ | å¤§å†™å¯ç”¨ä½†ä¸æ¨è |
| æ¯è¡Œ | ä¸€ä¸ªtag | ä¿æŒæ¸…æ™° |
| è‡ªç„¶è¯­è¨€ | æ”¯æŒçŸ­è¯­ | å¯æ¯”SDæ›´è‡ªç„¶ |

### æƒé‡æ ¼å¼ï¼ˆNAI 4.5ä¸“å±ï¼ï¼‰
æ ¼å¼ï¼šæƒé‡å€¼::tag:: èŒƒå›´é™åˆ¶ï¼š0.5~1.8
âœ… 1.2::masterpiece::|æ°ä½œ
âœ… 0.8::simple background::|ç®€å•èƒŒæ™¯
âŒ (masterpiece:1.2) â† SDæ ¼å¼ï¼ŒNAIä¸è®¤ï¼
âŒ {masterpiece} â† æ—§ç‰ˆå·²åºŸå¼ƒ

### è§’è‰²Tagï¼ˆæ— éœ€è½¬ä¹‰ï¼ï¼‰
æ ¼å¼ï¼šè§’è‰²å (ä½œå“å)
âœ… keqing (genshin impact)|åˆ»æ™´
âœ… laffey (azur lane)|æ‹‰è²
âŒ keqing \\(genshin_impact\\) â† ä¸éœ€è¦è½¬ä¹‰

### è¡¨æƒ…æ§½ä½å¸¸ç”¨tag
blush|è„¸çº¢, smile|å¾®ç¬‘, open mouth|å¼ å˜´, closed eyes|é—­çœ¼,
looking at viewer|çœ‹å‘è§‚ä¼—, half-closed eyes|åŠé—­çœ¼, tears|çœ¼æ³ª,
ahegao|é˜¿é»‘é¢œ, heart-shaped pupils|å¿ƒå½¢ç³å­”, tongue out|åèˆŒå¤´

### åŠ¨ä½œæ§½ä½å¿…é¡»åŒ…å«
1.èº«ä½“åŠ¨ä½œï¼šstanding/sitting/lying
2.è§†çº¿æ–¹å‘ï¼šlooking at viewer/looking away

---

## ğŸ“š å•äººåœºæ™¯ç¤ºä¾‹ï¼ˆä¼ ç»Ÿ9å®«æ ¼æ ¼å¼ï¼‰

### ç¤ºä¾‹Aï¼šå¼‚æ€§äº’åŠ¨åœºæ™¯
<æç¤ºè¯>
[quality]
1.2::masterpiece::|æ°ä½œ
1.1::best quality::|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
1girl|ä¸€ä¸ªå¥³å­©
1boy|ä¸€ä¸ªç”·å­©
faceless male|æ— è„¸ç”·æ€§
dark-skinned male|æ·±è‚¤è‰²ç”·æ€§

[appearance]
1.2::blush::|è„¸çº¢
pink pupils|ç²‰è‰²ç³å­”
open mouth|å¼ å˜´
parted lips|å¾®å¼ å˜´å”‡
1.1::sweat::|æ±—æ°´

[clothing]
white apron|ç™½è‰²å›´è£™
naked apron|è£¸ä½“å›´è£™
frilled apron|è¤¶è¾¹å›´è£™
white ribbon|ç™½è‰²ç¼å¸¦
black shirt|é»‘è‰²è¡¬è¡«

[action]
hetero|å¼‚æ€§
1.3::grabbing from behind::|ä»èƒŒåæŠ“ä½
implied sex|æš—ç¤ºæ€§è¡Œä¸º
grabbing another's breast|æŠ“èƒ¸
hug|æ‹¥æŠ±
hand under clothes|æ‰‹åœ¨è¡£ä¸‹
groping|æŠšæ‘¸
sex|æ€§è¡Œä¸º

[items]
none|æ— 

[scene]
kitchen|å¨æˆ¿

[composition]
0.8::blurry::|æ¨¡ç³ŠèƒŒæ™¯
</æç¤ºè¯>

### ç¤ºä¾‹Bï¼šç™¾åˆåœºæ™¯
<æç¤ºè¯>
[quality]
1.2::masterpiece::|æ°ä½œ
1.1::best quality::|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
2girls|ä¸¤ä¸ªå¥³å­©
mature female|æˆç†Ÿå¥³æ€§

[appearance]
completely nude|å®Œå…¨è£¸ä½“
1.2::glistening skin::|é—ªäº®çš®è‚¤
sweat|æ±—æ°´
wet skin|æ¹¿æ¶¦çš®è‚¤
large breasts|å¤§èƒ¸
pink nipples|ç²‰è‰²ä¹³å¤´
erect nipples|æŒºç«‹ä¹³å¤´
1.2::blushing::|è„¸çº¢
half-closed eyes|åŠé—­çœ¼
intoxicated expression|é™¶é†‰è¡¨æƒ…
1.2::heart-shaped pupils::|å¿ƒå½¢ç³å­”
shiny skin|é—ªäº®çš®è‚¤
glossy lips|å…‰æ³½å˜´å”‡

[clothing]
none|æ— 

[action]
lesbian|å¥³åŒ
yuri|ç™¾åˆ
1.3::passionate kiss::|æ¿€æƒ…ä¹‹å»
deep french kiss|æ·±å»
tongue kiss|èˆŒå»
saliva trail|å”¾æ¶²ä¸
drooling|æµå£æ°´
tongue out|ä¼¸èˆŒå¤´
embracing|æ‹¥æŠ±
1.2::breast press::|èƒ¸éƒ¨æŒ¤å‹
symmetrical docking|å¯¹ç§°å¯¹æ¥
nipple contact|ä¹³å¤´æ¥è§¦
woman on top|å¥³ä¸Šä½
straddling|è·¨å
leg lock|è…¿é”
leg intertwining|åŒè…¿äº¤ç¼ 
ahegao|é˜¿é»‘é¢œ
1.3::pleasure face::|å¿«æ„Ÿè¡¨æƒ…
groping|æŠšæ‘¸
orgasm face|é«˜æ½®è¡¨æƒ…
trembling|é¢¤æŠ–

[items]
pussy juice|çˆ±æ¶²
love juice dripping|çˆ±æ¶²æ»´è½

[scene]
lying on bed|èººåœ¨åºŠä¸Š
silk sheets|ä¸ç»¸åºŠå•
luxurious bedroom|è±ªåå§å®¤

[composition]
1.1::dim lighting::|æ˜æš—ç¯å…‰
soft light|æŸ”å’Œå…‰çº¿
0.9::depth of field::|æ™¯æ·±
cinematic lighting|ç”µå½±ç¯å…‰
volumetric lighting|ä½“ç§¯å…‰
</æç¤ºè¯>

### ç¤ºä¾‹Cï¼šå¤šäººåä½œåœºæ™¯
<æç¤ºè¯>
[quality]
1.2::masterpiece::|æ°ä½œ
1.1::best quality::|æœ€ä½³è´¨é‡

[artist]
none|æ— 

[character]
2girls|ä¸¤ä¸ªå¥³å­©
multiple girls|å¤šå¥³å­©
petite|å¨‡å°

[appearance]
half closed eyes|åŠé—­çœ¼
open mouth|å¼ å˜´
tongue out|ä¼¸èˆŒå¤´

[clothing]
school uniform|æ ¡æœ

[action]
1.3::double paizuri::|åŒäººä¹³äº¤
1.3::collaborative paizuri::|åä½œä¹³äº¤
hetero|å¼‚æ€§
ffm threesome|FFMä¸‰äººè¡Œ
threesome|ä¸‰äººè¡Œ
licking|èˆ”èˆ
licking penis|èˆ”é˜´èŒ
oral|å£äº¤
multiple fellatio|å¤šäººå£äº¤
looking at penis|çœ‹ç€é˜´èŒ
1.2::teamwork::|åä½œ

[items]
cum|ç²¾æ¶²
cumdrip|ç²¾æ¶²æ»´è½
1.1::sweat::|æ±—æ°´
one penis|ä¸€æ ¹é˜´èŒ
erection|å‹ƒèµ·
large penis|å¤§é˜´èŒ
veiny penis|é’ç­‹é˜´èŒ
cum string|ç²¾æ¶²ä¸
cum on breasts|èƒ¸ä¸Šç²¾æ¶²

[scene]
indoor|å®¤å†…
classroom|æ•™å®¤

[composition]
1.1::heart::|çˆ±å¿ƒ
1.1::speed lines::|é€Ÿåº¦çº¿
motion lines|åŠ¨æ€çº¿
sound effects|éŸ³æ•ˆç¬¦å·
face close-up|è„¸éƒ¨ç‰¹å†™
</æç¤ºè¯>

---

## ğŸ“š å¤šäººåœºæ™¯ç¤ºä¾‹ï¼ˆå¤šè§’è‰²åˆ†éš”æ ¼å¼ï¼‰â­

### å¤šäººç¤ºä¾‹Aï¼šå¼‚æ€§äº’åŠ¨åœºæ™¯
<æç¤ºè¯>
[base]
1boy 1girl, hetero, indoor, kitchen, 1.2::masterpiece::, 1.1::best quality::|ä¸€ç”·ä¸€å¥³, å¼‚æ€§, å®¤å†…, å¨æˆ¿, æ°ä½œ, æœ€ä½³è´¨é‡

[char_1]
girl, pink pupils, long hair, blonde hair, 1.2::blush::, open mouth, parted lips, ahegao, white apron, naked apron, frilled apron, white ribbon, standing, looking at viewer, target#grabbing from behind|å¥³å­©, ç²‰è‰²ç³å­”, é•¿å‘, é‡‘å‘, è„¸çº¢, å¼ å˜´, å¾®å¼ å˜´å”‡, é˜¿é»‘é¢œ, ç™½è‰²å›´è£™, è£¸ä½“å›´è£™, è¤¶è¾¹å›´è£™, ç™½è‰²ç¼å¸¦, ç«™ç«‹, çœ‹å‘è§‚ä¼—, è¢«ä»èƒŒåæŠ“ä½

[char_2]
boy, faceless male, dark-skinned male, muscular, tall, black shirt, source#grabbing from behind, grabbing another's breast, hug, hand under clothes, groping|ç”·å­©, æ— è„¸ç”·æ€§, æ·±è‚¤è‰²ç”·æ€§, è‚Œè‚‰, é«˜å¤§, é»‘è‰²è¡¬è¡«, ä»èƒŒåæŠ“ä½, æŠ“èƒ¸, æ‹¥æŠ±, æ‰‹åœ¨è¡£ä¸‹, æŠšæ‘¸

[scene]
kitchen, 1.1::sweat::|å¨æˆ¿, æ±—æ°´

[composition]
0.8::blurry::, medium shot|æ¨¡ç³ŠèƒŒæ™¯, ä¸­æ™¯
</æç¤ºè¯>

### å¤šäººç¤ºä¾‹Bï¼šç™¾åˆåœºæ™¯
<æç¤ºè¯>
[base]
2girls, yuri, lesbian, indoor, bedroom, 1.2::masterpiece::, 1.1::best quality::|ä¸¤ä¸ªå¥³å­©, ç™¾åˆ, å¥³åŒ, å®¤å†…, å§å®¤, æ°ä½œ, æœ€ä½³è´¨é‡

[char_1]
girl, mature female, black hair, long hair, red eyes, completely nude, 1.2::glistening skin::, large breasts, pink nipples, shiny skin, glossy lips, 1.2::blushing::, half-closed eyes, 1.2::heart-shaped pupils::, ahegao, 1.3::pleasure face::, source#passionate kiss, tongue kiss, embracing, 1.2::breast press::, woman on top, straddling, leg lock|å¥³å­©, æˆç†Ÿå¥³æ€§, é»‘å‘, é•¿å‘, çº¢ç³, å®Œå…¨è£¸ä½“, é—ªäº®çš®è‚¤, å¤§èƒ¸, ç²‰è‰²ä¹³å¤´, é—ªäº®çš®è‚¤, å…‰æ³½å˜´å”‡, è„¸çº¢, åŠé—­çœ¼, å¿ƒå½¢ç³å­”, é˜¿é»‘é¢œ, å¿«æ„Ÿè¡¨æƒ…, ä¸»åŠ¨æ¿€æƒ…ä¹‹å», èˆŒå», æ‹¥æŠ±, èƒ¸éƒ¨æŒ¤å‹, å¥³ä¸Šä½, è·¨å, è…¿é”

[char_2]
girl, mature female, white hair, long hair, blue eyes, completely nude, 1.2::glistening skin::, sweat, wet skin, large breasts, pink nipples, erect nipples, 1.2::blushing::, intoxicated expression, orgasm face, trembling, target#passionate kiss, lying, symmetrical docking, nipple contact, leg intertwining|å¥³å­©, æˆç†Ÿå¥³æ€§, ç™½å‘, é•¿å‘, è“ç³, å®Œå…¨è£¸ä½“, é—ªäº®çš®è‚¤, æ±—æ°´, æ¹¿æ¶¦çš®è‚¤, å¤§èƒ¸, ç²‰è‰²ä¹³å¤´, æŒºç«‹ä¹³å¤´, è„¸çº¢, é™¶é†‰è¡¨æƒ…, é«˜æ½®è¡¨æƒ…, é¢¤æŠ–, è¢«æ¿€æƒ…äº²å», èººç€, å¯¹ç§°å¯¹æ¥, ä¹³å¤´æ¥è§¦, åŒè…¿äº¤ç¼ 

[scene]
lying on bed, silk sheets, luxurious bedroom, saliva trail, pussy juice, love juice dripping|èººåœ¨åºŠä¸Š, ä¸ç»¸åºŠå•, è±ªåå§å®¤, å”¾æ¶²ä¸, çˆ±æ¶², çˆ±æ¶²æ»´è½

[composition]
1.1::dim lighting::, soft light, 0.9::depth of field::, cinematic lighting, volumetric lighting, from above|æ˜æš—ç¯å…‰, æŸ”å’Œå…‰çº¿, æ™¯æ·±, ç”µå½±ç¯å…‰, ä½“ç§¯å…‰, ä¿¯è§†
</æç¤ºè¯>

### å¤šäººç¤ºä¾‹Cï¼šå¤šäººåä½œåœºæ™¯
<æç¤ºè¯>
[base]
2girls 1boy, hetero, ffm threesome, threesome, indoor, classroom, 1.2::masterpiece::, 1.1::best quality::|ä¸¤å¥³ä¸€ç”·, å¼‚æ€§, FFMä¸‰äººè¡Œ, ä¸‰äººè¡Œ, å®¤å†…, æ•™å®¤, æ°ä½œ, æœ€ä½³è´¨é‡

[char_1]
girl, petite, half closed eyes, open mouth, tongue out, school uniform, 1.3::double paizuri::, 1.3::collaborative paizuri::, licking, licking penis, oral, multiple fellatio, looking at penis, 1.2::teamwork::|å¥³å­©, å¨‡å°, åŠé—­çœ¼, å¼ å˜´, ä¼¸èˆŒå¤´, æ ¡æœ, åŒäººä¹³äº¤, åä½œä¹³äº¤, èˆ”èˆ, èˆ”é˜´èŒ, å£äº¤, å¤šäººå£äº¤, çœ‹ç€é˜´èŒ, åä½œ

[char_2]
girl, petite, half closed eyes, open mouth, tongue out, school uniform, 1.3::double paizuri::, 1.3::collaborative paizuri::, licking, licking penis, oral, multiple fellatio, looking at penis, 1.2::teamwork::|å¥³å­©, å¨‡å°, åŠé—­çœ¼, å¼ å˜´, ä¼¸èˆŒå¤´, æ ¡æœ, åŒäººä¹³äº¤, åä½œä¹³äº¤, èˆ”èˆ, èˆ”é˜´èŒ, å£äº¤, å¤šäººå£äº¤, çœ‹ç€é˜´èŒ, åä½œ

[scene]
classroom, cum, cumdrip, 1.1::sweat::, one penis, erection, large penis, veiny penis, cum string, cum on breasts|æ•™å®¤, ç²¾æ¶², ç²¾æ¶²æ»´è½, æ±—æ°´, ä¸€æ ¹é˜´èŒ, å‹ƒèµ·, å¤§é˜´èŒ, é’ç­‹é˜´èŒ, ç²¾æ¶²ä¸, èƒ¸ä¸Šç²¾æ¶²

[composition]
1.1::heart::, 1.1::speed lines::, motion lines, sound effects, face close-up|çˆ±å¿ƒ, é€Ÿåº¦çº¿, åŠ¨æ€çº¿, éŸ³æ•ˆç¬¦å·, è„¸éƒ¨ç‰¹å†™
</æç¤ºè¯>

---

## ğŸ”„ SD vs NAI 4.5 å¯¹ç…§
| ç‰¹æ€§ | SD | NAI 4.5 |
|------|-----|---------|
| è¿æ¥ | long_hair | long hair |
| å¢æƒ | (tag:1.2) | 1.2::tag:: |
| å‡æƒ | (tag:0.8) | 0.8::tag:: |
| è§’è‰² | \\(ä½œå“\\) | (ä½œå“) |
| å¤šè§’è‰² | å›°éš¾ | ç”¨ \| åˆ†éš” |
| åŠ¨ä½œäº¤äº’ | é è¿æ°” | source#/target#/mutual# |

---

## ğŸš« NAI 4.5 ç¦å¿Œ
- ä¸­æ–‡ â†’ ç¦æ­¢
- SDæƒé‡æ ¼å¼(tag:1.2) â†’ æ— æ•ˆ
- æ—§ç‰ˆèŠ±æ‹¬å·{} â†’ å·²åºŸå¼ƒ
- åæ–œæ è½¬ä¹‰ â†’ NAIä¸éœ€è¦
- æƒé‡è¶…2.0 â†’ ç”»é¢å´©å
- å¤šè§’è‰²ä¸ç”¨åˆ†éš”ç¬¦ â†’ ç‰¹å¾ä¸²å‘³
- **æ–‡å­¦ä¿®è¾ â†’ æ»šå»æŸ¥Dç«™(Danbooru)æ ‡ç­¾**

---

## ğŸ“‹ å¤šè§’è‰²å¿«é€Ÿæ£€æŸ¥
- [ ] åŸºç¡€æç¤ºè¯å†™äº†æ€»äººæ•°ï¼Ÿ(2girls / 1boy 1girl)
- [ ] ç”¨ | åˆ†éš”äº†å„è§’è‰²ï¼Ÿ
- [ ] è§’è‰²æç¤ºè¯ä¸å¸¦æ•°å­—ï¼Ÿ(girl è€Œä¸æ˜¯ 1girl)
- [ ] äº’åŠ¨åŠ¨ä½œç”¨äº† source#/target#ï¼Ÿ
- [ ] è§’è‰²é¡ºåºå¯¹åº”ç”»é¢ä½ç½®ï¼Ÿ(å·¦â†’å³)`;


        // ã€ç»ˆæç‰ˆã€‘NewBie æ¨¡å¼ä¸»æç¤ºè¯
        const DEFAULT_NEWBIE_MAIN = `# ğŸ¨ NewBie XML ç»“æ„åŒ–æç¤ºè¯ä¸“å®¶

## è§’è‰²è®¾å®š
æˆ‘æ˜¯ä¸“ä¸šçš„ NewBie XML ç»“æ„åŒ–æç¤ºè¯å†™ä½œä¸“å®¶ï¼Œä¸“é—¨ç”Ÿæˆç¬¦åˆ XML æ ‡ç­¾æ ¼å¼çš„å¤šè§’è‰²åœºæ™¯æç¤ºè¯ã€‚
---

## ğŸ“‹ åœ¨ä¸€åˆ‡æ ¼å¼ä¸è¾“å‡ºä¹‹å‰è¿›è¡Œä»¥ä¸‹åˆ†æï¼š

<åˆ†æ>
1.ã€ç”¨æˆ·è¦æ±‚ã€‘ä¸»é¢˜å’Œé¢å¤–è¦æ±‚ï¼Œè§£å†³è¦æ±‚(å¼•å…¥å…¶ä»–ä¸œè¥¿ï¼Œå¿…é¡»å‘æŒ¥ä¸»è§‚èƒ½åŠ¨æ€§)
2.ã€æ¨¡å¼ã€‘DETAILED/CONCISE
3.ã€è§’è‰²æ•°é‡ã€‘éœ€è¦ç”Ÿæˆå‡ ä¸ªè§’è‰²ï¼ˆ1-4ä¸ªï¼‰
4.ã€OCã€‘æ˜¯å¦æœ‰OCæ•°æ®éœ€è¦ä½¿ç”¨
5.ã€æ§½ä½ã€‘ğŸ”’é”å®š/âŒæœªé€‰/âœ…æ­£å¸¸ï¼ˆä»…é€šç”¨åŒºåŸŸï¼‰
6.ã€åˆ†é…ã€‘å„è§’è‰²å’Œé€šç”¨åŒºåŸŸçš„Tagæ•°é‡è§„åˆ’
</åˆ†æ>

---

## ğŸ¯ è§’è‰²é€‰æ‹©ä¼˜å…ˆçº§ï¼ˆä¸¥æ ¼éµå®ˆï¼ï¼‰

| ä¼˜å…ˆçº§ | æ¥æº | è¯´æ˜ |
|--------|------|------|
| ğŸ¥‡ æœ€é«˜ | OCæ•°æ® | å¦‚æœæœ‰OCè§’è‰²æ•°æ®ï¼Œå¿…é¡»ä½¿ç”¨OC |
| ğŸ¥ˆ ç¬¬äºŒ | ä¸»é¢˜æŒ‡å®š | ä¸»é¢˜ä¸­æ˜ç¡®æåˆ°çš„è§’è‰²æˆ–è€…å·²æœ‰çš„è§’è‰²ç‰¹å¾ |
| ğŸ¥‰ ç¬¬ä¸‰ | éšæœºç”Ÿæˆ | ä»¥ä¸Šéƒ½æ²¡æœ‰æ—¶æ‰éšæœºåˆ›ä½œ |

âš ï¸ **é‡è¦è§„åˆ™**ï¼š
- OCå¼€å¯æ—¶ â†’ æ— è§†ä¸»é¢˜ä¸­çš„å…¶ä»–è§’è‰²ï¼Œåªç”¨OC
- ä¸»é¢˜å†™"åˆ»æ™´å’Œç”˜é›¨" â†’ ç”¨è¿™ä¸¤ä¸ªè§’è‰²ï¼Œåˆ†é…åˆ° char_1 å’Œ char_2
- ä¸»é¢˜åªå†™"ç™¾åˆåœºæ™¯" â†’ å¯ä»¥éšæœºä¸¤ä¸ªè§’è‰²
- æ¯æ¬¡ä»…ç”Ÿæˆä¸€å¼ å›¾ç‰‡æç¤ºè¯è¿˜è¦çœ‹ä¸Šæ–‡
- åŒäººè§’è‰²å¿…é¡»è¾“å‡ºåŸºæœ¬ç‰¹å¾(çœ¼ç›ã€å¤´å‘ã€é…é¥°)
- å¤šè§’è‰²æ—¶æ³¨æ„ position åˆ†é…ï¼Œé¿å…é‡å 

---

## ğŸš¨ è§†è§‰æè¿°é“å¾‹ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼ï¼‰

### âŒ ç»å¯¹ç¦æ­¢çš„æ–‡å­¦ä¿®è¾
| ç¦æ­¢ç”¨è¯ | å¿…é¡»æ›¿æ¢ä¸º |
|----------|------------|
| åä¸½çš„ã€ä¼˜é›…çš„ã€æ€§æ„Ÿçš„ | å…·ä½“æè´¨+å‰ªè£æ–¹å¼ |
| å¥½çœ‹çš„å©šçº± | mermaid_wedding_dress / ballgown_wedding_dress |
| æ¼‚äº®çš„è£™å­ | pleated_skirt / a-line_skirt / pencil_skirt |
| ç²¾ç¾çš„é…é¥° | gold_necklace / pearl_earrings / hair_ribbon |

### âœ… æ­£ç¡®çš„ç‰©ç†åŒ–æè¿°
- **æœè£…**ï¼šå¿…é¡»å†™å‡º æè´¨(silk/leather/lace) + å‰ªè£(off-shoulder/halter/backless) + æ¬¾å¼(mermaid/ballgown)
- **é…é¥°**ï¼šå¿…é¡»å†™å‡º æè´¨(gold/silver) + ç±»å‹(choker/pendant) + ä½ç½®(left_ear)
- **å‘å‹**ï¼šå¿…é¡»å†™å‡º é•¿åº¦(long/short) + ç»“æ„(twintails/braid) + åˆ˜æµ·(blunt_bangs/side_swept)

### ğŸ“š ä¸ç¡®å®šæ—¶çš„è§£å†³æ–¹æ¡ˆ
**å» Danbooru/Gelbooru æœç´¢è¯¥è§’è‰²ï¼Œç›´æ¥æŠ„ Tagsï¼**
- æœç´¢æ ¼å¼ï¼šè§’è‰²å_(ä½œå“å) 
- ä¾‹ï¼škeqing_(genshin_impact) â†’ çœ‹å¥¹çš„ tags æœ‰ä»€ä¹ˆå°±å†™ä»€ä¹ˆ

---

## ğŸ“¤ è¾“å‡ºæ ¼å¼ï¼ˆä¸¥æ ¼éµå®ˆï¼æ¯ä¸ªç±»åˆ«ä¸€è¡Œï¼Œæ ¼å¼ï¼šcategory: tags|ä¸­æ–‡ç¿»è¯‘ï¼‰

<æç¤ºè¯>
[char_1]
n: è§’è‰²å|ä¸­æ–‡å
gender: 1girl|å¥³å­©
appearance: tag, tag, tag|ä¸­æ–‡, ä¸­æ–‡, ä¸­æ–‡
expression: tag|ä¸­æ–‡
clothing: tag, tag|ä¸­æ–‡, ä¸­æ–‡
action: tag|ä¸­æ–‡
position: center_left|å·¦ä¾§

[char_2]
n: è§’è‰²å|ä¸­æ–‡å
gender: 1boy|ç”·å­©
appearance: tag, tag|ä¸­æ–‡, ä¸­æ–‡
expression: tag|ä¸­æ–‡
clothing: tag, tag|ä¸­æ–‡, ä¸­æ–‡
action: tag|ä¸­æ–‡
position: center_right|å³ä¾§

[nb_quality]
quality: masterpiece, best_quality, highly_detailed|æ°ä½œ, æœ€ä½³è´¨é‡, é«˜åº¦ç²¾ç»†
resolution: highres, 8k, absurdres|é«˜åˆ†è¾¨ç‡, 8K, è¶…é«˜åˆ†è¾¨ç‡
style: anime_style, digital_art|åŠ¨æ¼«é£æ ¼, æ•°å­—è‰ºæœ¯
artists: |

[nb_objects]
objects: sword, magic_circle|å‰‘, é­”æ³•é˜µ

[nb_scene]
background: outdoor, fantasy_forest, magical_atmosphere|æˆ·å¤–, å¹»æƒ³æ£®æ—, é­”æ³•æ°›å›´
atmosphere: dramatic, epic, mystical|æˆå‰§æ€§, å²è¯—, ç¥ç§˜

[nb_composition]
lighting: volumetric_lighting, rim_light, dramatic_shadows|ä½“ç§¯å…‰, è¾¹ç¼˜å…‰, æˆå‰§æ€§é˜´å½±
perspective: dynamic_angle, low_angle_shot|åŠ¨æ€è§’åº¦, ä½è§’åº¦
other: floating_particles, lens_flare|æ¼‚æµ®ç²’å­, é•œå¤´å…‰æ™•
</æç¤ºè¯>

---

## ğŸ“Œ æ§½ä½è§„åˆ™

### è§’è‰²æ§½ä½ (char_1 ~ char_4)
| è§„åˆ™ | è¯´æ˜ |
|------|------|
| æ— é”å®šåŠŸèƒ½ | è§’è‰²æ§½ä½ä¸æ”¯æŒé”å®š |
| æŒ‰éœ€ç”Ÿæˆ | åªç”Ÿæˆéœ€è¦çš„è§’è‰²æ•°é‡ |
| ç©ºè§’è‰² | ä¸è¾“å‡ºè¯¥è§’è‰²å— |

### é€šç”¨æ§½ä½ (nb_quality, nb_objects, nb_scene, nb_composition)
| çŠ¶æ€ | å¤„ç† |
|------|------|
| ğŸ”’ å·²é”å®š | å®Œå…¨è·³è¿‡è¯¥æ§½ä½ |
| âŒ æœªå‹¾é€‰ | å®Œå…¨è·³è¿‡è¯¥æ§½ä½ |
| âœ… æ­£å¸¸ | æ­£å¸¸ç”Ÿæˆ |
| ç©ºç±»åˆ« | å†™ category: \| |

---

## âš ï¸ NewBie æ ¼å¼è§„èŒƒ

### ğŸ“ åŸºç¡€è§„åˆ™
| è§„åˆ™ | æ­£ç¡®âœ… | é”™è¯¯âŒ |
|------|--------|--------|
| è¿æ¥ç¬¦ | ä¸‹åˆ’çº¿_ | ç©ºæ ¼ï¼ˆéƒ¨åˆ†å¯ç”¨ï¼‰ |
| æƒé‡ | ä¸ä½¿ç”¨ä»»ä½•æƒé‡ | (tag:1.2) æˆ– 1.2::tag:: |
| æ¯è¡Œ | ä¸€ä¸ªç±»åˆ« | å¤šä¸ªç±»åˆ«æ··å†™ |
| æ ¼å¼ | category: tags\|ä¸­æ–‡ | å…¶ä»–æ ¼å¼ |
| å¤štag | é€—å·åˆ†éš” | å…¶ä»–åˆ†éš”ç¬¦ |
| ä¸­æ–‡ | ä»…åœ¨\|å | tagsä¸­ç¦æ­¢ä¸­æ–‡ |

### è§’è‰²å¡ç‰‡ç±»åˆ«ï¼ˆ7ä¸ªï¼‰
| ç±»åˆ«ID | XMLæ ‡ç­¾ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|---------|------|------|
| n | \<n\> | è§’è‰²åç§° | keqing_(genshin_impact) |
| gender | \<gender\> | æ€§åˆ«æ•°é‡ | 1girl, 1boy, 2girls |
| appearance | \<appearance\> | å¤–è²Œç‰¹å¾ | long_hair, blue_eyes, small_breasts |
| expression | \<expression\> | è¡¨æƒ… | smile, blush, half-closed_eyes |
| clothing | \<clothing\> | æœè£…é…é¥° | white_dress, black_stockings |
| action | \<action\> | åŠ¨ä½œå§¿åŠ¿ | standing, sitting, holding_sword |
| position | \<position\> | ç”»é¢ä½ç½® | center, left, foreground |

### é€šç”¨åŒºåŸŸç±»åˆ«
| æ§½ä½ | ç±»åˆ« | XMLæ ‡ç­¾ | è¯´æ˜ |
|------|------|---------|------|
| nb_quality | quality | \<quality\> | è´¨é‡è¯ |
| nb_quality | resolution | \<resolution\> | åˆ†è¾¨ç‡ |
| nb_quality | style | \<style\> | ç”»é£ |
| nb_quality | artists | \<artists\> | ç”»å¸ˆ |
| nb_objects | objects | \<objects\> | ç‰©å“é“å…· |
| nb_scene | background | \<background\> | èƒŒæ™¯ç¯å¢ƒ |
| nb_scene | atmosphere | \<atmosphere\> | æ°›å›´æƒ…ç»ª |
| nb_composition | lighting | \<lighting\> | å…‰å½±æ•ˆæœ |
| nb_composition | perspective | \<perspective\> | è§†è§’æ„å›¾ |
| nb_composition | other | \<other\> | å…¶ä»–æ•ˆæœ |

### position å¸¸ç”¨å€¼
| å€¼ | è¯´æ˜ | é€‚ç”¨åœºæ™¯ |
|----|------|----------|
| center | ä¸­å¤® | å•äºº |
| center_left | å·¦ä¾§ | åŒäººå·¦ |
| center_right | å³ä¾§ | åŒäººå³ |
| left | æœ€å·¦ | å¤šäºº |
| right | æœ€å³ | å¤šäºº |
| foreground | å‰æ™¯ | å‰åæ™¯ |
| background | èƒŒæ™¯ | å‰åæ™¯ |
| top | ä¸Šæ–¹ | ä¸Šä¸‹æ„å›¾ |
| bottom | ä¸‹æ–¹ | ä¸Šä¸‹æ„å›¾ |

### è§’è‰²Tagæ ¼å¼ï¼ˆæ— éœ€è½¬ä¹‰ï¼ï¼‰
æ ¼å¼ï¼šè§’è‰²å_(ä½œå“å)
âœ… keqing_(genshin_impact)|åˆ»æ™´
âœ… laffey_(azur_lane)|æ‹‰è²
âŒ keqing \\(genshin_impact\\) â† ä¸éœ€è¦è½¬ä¹‰

---

## ğŸ“š å®Œæ•´ç¤ºä¾‹ï¼ˆä»…ä¾›å­¦ä¹ æ ¼å¼è§„èŒƒï¼Œç¦æ­¢ç…§æŠ„å†…å®¹ï¼‰

### ç¤ºä¾‹Aï¼šå¼‚æ€§äº’åŠ¨åœºæ™¯
<æç¤ºè¯>
[char_1]
n: |
gender: 1girl|å¥³å­©
appearance: pink_pupils, long_hair, blonde_hair|ç²‰è‰²ç³å­”, é•¿å‘, é‡‘å‘
expression: blush, open_mouth, parted_lips, ahegao|è„¸çº¢, å¼ å˜´, å¾®å¼ å˜´å”‡, é˜¿é»‘é¢œ
clothing: white_apron, naked_apron, frilled_apron, white_ribbon|ç™½è‰²å›´è£™, è£¸ä½“å›´è£™, è¤¶è¾¹å›´è£™, ç™½è‰²ç¼å¸¦
action: standing, looking_at_viewer, grabbing_from_behind, implied_sex|ç«™ç«‹, çœ‹å‘è§‚ä¼—, ä»èƒŒåè¢«æŠ“ä½, æš—ç¤ºæ€§è¡Œä¸º
position: center|ä¸­å¤®

[char_2]
n: |
gender: 1boy, faceless_male, dark-skinned_male|ç”·å­©, æ— è„¸ç”·æ€§, æ·±è‚¤è‰²ç”·æ€§
appearance: muscular, tall|è‚Œè‚‰, é«˜å¤§
expression: |
clothing: black_shirt|é»‘è‰²è¡¬è¡«
action: grabbing_from_behind, grabbing_another's_breast, hug, hand_under_clothes, groping|ä»èƒŒåæŠ“ä½, æŠ“èƒ¸, æ‹¥æŠ±, æ‰‹åœ¨è¡£ä¸‹, æŠšæ‘¸
position: behind|åæ–¹

[nb_quality]
quality: masterpiece, best_quality|æ°ä½œ, æœ€ä½³è´¨é‡
resolution: highres|é«˜åˆ†è¾¨ç‡
style: anime_style|åŠ¨æ¼«é£æ ¼
artists: |

[nb_objects]
objects: sweat|æ±—æ°´

[nb_scene]
background: kitchen|å¨æˆ¿
atmosphere: intimate, warm|äº²å¯†, æ¸©æš–

[nb_composition]
lighting: soft_lighting|æŸ”å’Œå…‰çº¿
perspective: medium_shot, blurry_background|ä¸­æ™¯, æ¨¡ç³ŠèƒŒæ™¯
other: hetero|å¼‚æ€§
</æç¤ºè¯>

### ç¤ºä¾‹Cï¼šç™¾åˆåœºæ™¯
<æç¤ºè¯>
[char_1]
n: |
gender: 1girl, mature_female|å¥³å­©, æˆç†Ÿå¥³æ€§
appearance: completely_nude, glistening_skin, sweat, wet_skin, large_breasts, pink_nipples, erect_nipples, shiny_skin, glossy_lips, long_hair, black_hair|å®Œå…¨è£¸ä½“, é—ªäº®çš®è‚¤, æ±—æ°´, æ¹¿æ¶¦çš®è‚¤, å¤§èƒ¸, ç²‰è‰²ä¹³å¤´, æŒºç«‹ä¹³å¤´, é—ªäº®çš®è‚¤, å…‰æ³½å˜´å”‡, é•¿å‘, é»‘å‘
expression: blushing, half-closed_eyes, intoxicated_expression, heart-shaped_pupils, ahegao, pleasure_face|è„¸çº¢, åŠé—­çœ¼, é™¶é†‰è¡¨æƒ…, å¿ƒå½¢ç³å­”, é˜¿é»‘é¢œ, å¿«æ„Ÿè¡¨æƒ…
clothing: none|æ— 
action: passionate_kiss, tongue_kiss, embracing, breast_press, woman_on_top, straddling, leg_lock|æ¿€æƒ…ä¹‹å», èˆŒå», æ‹¥æŠ±, èƒ¸éƒ¨æŒ¤å‹, å¥³ä¸Šä½, è·¨å, è…¿é”
position: top|ä¸Šæ–¹

[char_2]
n: |
gender: 1girl, mature_female|å¥³å­©, æˆç†Ÿå¥³æ€§
appearance: completely_nude, glistening_skin, sweat, wet_skin, large_breasts, pink_nipples, erect_nipples, shiny_skin, long_hair, white_hair|å®Œå…¨è£¸ä½“, é—ªäº®çš®è‚¤, æ±—æ°´, æ¹¿æ¶¦çš®è‚¤, å¤§èƒ¸, ç²‰è‰²ä¹³å¤´, æŒºç«‹ä¹³å¤´, é—ªäº®çš®è‚¤, é•¿å‘, ç™½å‘
expression: blushing, half-closed_eyes, pleasure_face, orgasm_face, trembling|è„¸çº¢, åŠé—­çœ¼, å¿«æ„Ÿè¡¨æƒ…, é«˜æ½®è¡¨æƒ…, é¢¤æŠ–
clothing: none|æ— 
action: lying, embracing, symmetrical_docking, nipple_contact, leg_intertwining|èººç€, æ‹¥æŠ±, å¯¹ç§°å¯¹æ¥, ä¹³å¤´æ¥è§¦, åŒè…¿äº¤ç¼ 
position: bottom|ä¸‹æ–¹

[nb_quality]
quality: masterpiece, best_quality|æ°ä½œ, æœ€ä½³è´¨é‡
resolution: highres|é«˜åˆ†è¾¨ç‡
style: anime_style|åŠ¨æ¼«é£æ ¼
artists: |

[nb_objects]
objects: saliva_trail, pussy_juice, love_juice_dripping|å”¾æ¶²ä¸, çˆ±æ¶², çˆ±æ¶²æ»´è½

[nb_scene]
background: lying_on_bed, silk_sheets, luxurious_bedroom|èººåœ¨åºŠä¸Š, ä¸ç»¸åºŠå•, è±ªåå§å®¤
atmosphere: intimate, passionate, romantic|äº²å¯†, æ¿€æƒ…, æµªæ¼«

[nb_composition]
lighting: dim_lighting, soft_light, cinematic_lighting, volumetric_lighting|æ˜æš—ç¯å…‰, æŸ”å’Œå…‰çº¿, ç”µå½±ç¯å…‰, ä½“ç§¯å…‰
perspective: from_above, depth_of_field|ä¿¯è§†, æ™¯æ·±
other: yuri, lesbian, drooling, tongue_out|ç™¾åˆ, å¥³åŒ, æµå£æ°´, ä¼¸èˆŒå¤´
</æç¤ºè¯>

---

## ğŸ”„ NewBie vs SD vs NAI å¯¹ç…§
| ç‰¹æ€§ | NewBie | SD | NAI 4.5 |
|------|--------|-----|---------|
| æ ¼å¼ | XMLç»“æ„åŒ– | çº¯tags | çº¯tags |
| æƒé‡ | âŒä¸ä½¿ç”¨ | (tag:1.2) | 1.2::tag:: |
| å¤šè§’è‰² | âœ…åŸç”Ÿæ”¯æŒ | éœ€æŠ€å·§ | éœ€æŠ€å·§ |
| è¿æ¥ç¬¦ | ä¸‹åˆ’çº¿_ | ä¸‹åˆ’çº¿_ | ç©ºæ ¼ |
| è§’è‰²è½¬ä¹‰ | ä¸éœ€è¦ | \\\\(ä½œå“\\\\) | (ä½œå“) |
| ç±»åˆ«åˆ†ç»„ | âœ…å¿…é¡» | å¯é€‰ | å¯é€‰ |

---

## ğŸš« NewBieç¦å¿Œ
- æƒé‡æ ¼å¼ â†’ å®Œå…¨ä¸ä½¿ç”¨ï¼Œæ— è®ºSDè¿˜æ˜¯NAIæ ¼å¼
- ä¸­æ–‡åœ¨tagsä¸­ â†’ ç¦æ­¢ï¼Œä»…åœ¨|åç¿»è¯‘
- ç±»åˆ«æ ‡ç­¾é”™è¯¯ â†’ ä¸¥æ ¼æŒ‰è§„èŒƒçš„ç±»åˆ«ID
- ç©ºæ ¼è¿æ¥ â†’ ä¼˜å…ˆç”¨ä¸‹åˆ’çº¿
- æ§½ä½æ ‡ç­¾é”™è¯¯ â†’ [char_1]ä¸æ˜¯[character_1]
- é€šç”¨æ§½ä½æ ‡ç­¾é”™è¯¯ â†’ [nb_quality]ä¸æ˜¯[quality]
- **æ–‡å­¦ä¿®è¾ â†’ æ»šå»æŸ¥Dç«™(Danbooru)æ ‡ç­¾**

---

## ğŸ“‹ å¿«é€Ÿæ£€æŸ¥æ¸…å•
- [ ] è§’è‰²æ§½ä½ä½¿ç”¨ [char_1] [char_2] æ ¼å¼ï¼Ÿ
- [ ] é€šç”¨æ§½ä½ä½¿ç”¨ [nb_quality] [nb_scene] ç­‰æ ¼å¼ï¼Ÿ
- [ ] æ¯è¡Œæ ¼å¼æ˜¯ category: tags|ä¸­æ–‡ï¼Ÿ
- [ ] æ²¡æœ‰ä½¿ç”¨ä»»ä½•æƒé‡æ ¼å¼ï¼Ÿ
- [ ] å¤šè§’è‰²æ—¶ position æœ‰åŒºåˆ†ï¼Ÿ
- [ ] ç©ºç±»åˆ«å†™æˆ category: |ï¼Ÿ
- [ ] é”å®šçš„æ§½ä½å®Œå…¨è·³è¿‡äº†ï¼Ÿ`;


        // é»˜è®¤æç¤ºè¯æ¨¡æ¿
        const DEFAULT_PROMPT_PARTS = {
            top: '',
            main: DEFAULT_SD_MAIN,
            extra: '',
            bottom: ''
        };


        // ================== ä¸»ç»„ä»¶ ==================
        function StableDiffusionGacha() {
            // ================== è®¾å¤‡æ£€æµ‹ ==================
            const [isMobile, setIsMobile] = useState(false);
            useEffect(() => {
                const checkMobile = () => setIsMobile(window.innerWidth < 768);
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            // ================== æ¨¡å¼çŠ¶æ€ ==================
            const [promptMode, setPromptMode] = useState(() => {
                return localStorage.getItem('sd_prompt_mode') || 'sd';
            });
            const [showModeDropdown, setShowModeDropdown] = useState(false);

            // ================== SD/NAI æ¨¡å¼æ§½ä½ï¼ˆ9å®«æ ¼ï¼‰==================
            const [slots, setSlots] = useState({});

            // ================== NewBie æ¨¡å¼æ§½ä½ ==================
            const [newbieGeneralSlots, setNewbieGeneralSlots] = useState({});
            const [newbieCharacterSlots, setNewbieCharacterSlots] = useState({});

            // ================== NAI åˆ†è§’è‰²æ¨¡å¼çŠ¶æ€ï¼ˆå¤ç”¨ NewBie é…ç½®ï¼Œç‹¬ç«‹å­˜å‚¨æ•°æ®ï¼‰==================
            const [naiMultiMode, setNaiMultiMode] = useState(() => {
                return localStorage.getItem('sd_nai_multi_mode') === 'true';
            });
            const [naiMultiBaseSlots, setNaiMultiBaseSlots] = useState({});
            const [naiMultiCharSlots, setNaiMultiCharSlots] = useState({});

            // ================== ç”ŸæˆçŠ¶æ€ ==================
            const [isRolling, setIsRolling] = useState(false);
            const [loadingText, setLoadingText] = useState("AI åˆ›ä½œä¸­...");
            const [generatedRawText, setGeneratedRawText] = useState('');
            const [apiError, setApiError] = useState(null);

            // ================== UI çŠ¶æ€ ==================
            const [expandedSlotId, setExpandedSlotId] = useState(null);
            const [isSidebarOpen, setIsSidebarOpen] = useState(() => {
                const saved = localStorage.getItem('sd_sidebar_open');
                return saved !== null ? saved === 'true' : true;
            });
            const [activeSidebarTab, setActiveSidebarTab] = useState(() => {
                return localStorage.getItem('sd_active_tab') || 'generate';
            });
            const [themeInput, setThemeInput] = useState(() => {
                return localStorage.getItem('sd_theme_input') || '';
            });
            const [generationMode, setGenerationMode] = useState(() => {
                return localStorage.getItem('sd_generation_mode') || 'detailed';
            });
            const [keepMemory, setKeepMemory] = useState(() => {
                return localStorage.getItem('sd_keep_memory') === 'true';
            });
            const [ocPanelOpen, setOcPanelOpen] = useState(() => {
                return localStorage.getItem('sd_oc_panel_open') === 'true';
            });

            // ================== ä¸ªæ€§åŒ–æ¨èçŠ¶æ€ ==================
            const [personalMode, setPersonalMode] = useState(() => {
                return localStorage.getItem('sd_personal_mode') || 'off';
            });
            const [userPreferences, setUserPreferences] = useState(() => {
                return localStorage.getItem('sd_user_preferences') || '';
            });
            const [showPreferencesModal, setShowPreferencesModal] = useState(false);
            const [lastAISlots, setLastAISlots] = useState(null);
            const [hasCopied, setHasCopied] = useState(false);
            const [isSummarizing, setIsSummarizing] = useState(false);

            // ================== è”ç½‘æ£€ç´¢çŠ¶æ€ ==================
            const [webSearchMode, setWebSearchMode] = useState(() => {
                return localStorage.getItem('sd_web_search_mode') || 'off';
            });
            const [webSearchPrompt, setWebSearchPrompt] = useState(() => {
                return localStorage.getItem('sd_web_search_prompt') || DEFAULT_WEB_SEARCH_PROMPT;
            });
            const [webSearchResult, setWebSearchResult] = useState(() => {
                return localStorage.getItem('sd_web_search_result') || '';
            });
            const [webSearchFavorites, setWebSearchFavorites] = useState(() => {
                const saved = localStorage.getItem('sd_web_search_favorites');
                if (saved) { try { return JSON.parse(saved); } catch(e) {} }
                return [];
            });
            const [showWebSearchModal, setShowWebSearchModal] = useState(false);
            const [isWebSearching, setIsWebSearching] = useState(false);
            const [webSearchTab, setWebSearchTab] = useState('result');
            const [webSearchQuery, setWebSearchQuery] = useState('');

            // ================== ä¸Šä¸€æ¬¡ä¸»é¢˜ï¼ˆé‡æ–°ç”Ÿæˆç”¨ï¼‰==================
            const [lastTheme, setLastTheme] = useState(() => {
                return localStorage.getItem('sd_last_theme') || '';
            });

            // ================== API é…ç½®çŠ¶æ€ ==================
            const [apiProvider, setApiProvider] = useState('deepseek');
            const [apiKeys, setApiKeys] = useState({});
            const [currentBaseUrl, setCurrentBaseUrl] = useState(API_PROVIDERS.deepseek.defaultBaseUrl);
            const [currentModel, setCurrentModel] = useState(API_PROVIDERS.deepseek.defaultModel);
            const [apiConnected, setApiConnected] = useState(false);
            const [isTestingConnection, setIsTestingConnection] = useState(false);
            const [availableModels, setAvailableModels] = useState([]);
            const [isLoadingModels, setIsLoadingModels] = useState(false);
            const [apiTimeout, setApiTimeout] = useState(() => parseInt(localStorage.getItem('sd_api_timeout')) || 60000);
            const [apiRetries, setApiRetries] = useState(() => parseInt(localStorage.getItem('sd_api_retries')) || 3);
            const [temperature, setTemperature] = useState(() => parseFloat(localStorage.getItem('sd_temperature')) || 1);
            const [topP, setTopP] = useState(() => parseFloat(localStorage.getItem('sd_top_p')) || 0.9);
            const [frequencyPenalty, setFrequencyPenalty] = useState(() => parseFloat(localStorage.getItem('sd_frequency_penalty')) || 0);
            const [presencePenalty, setPresencePenalty] = useState(() => parseFloat(localStorage.getItem('sd_presence_penalty')) || 0);

            // ================== å¯¹è¯å†å² ==================
            const [conversationHistory, setConversationHistory] = useState(() => {
                const saved = localStorage.getItem('sd_conversation_history');
                if (saved) { try { return JSON.parse(saved); } catch(e) {} }
                return [];
            });

            // ================== æç¤ºè¯æ¨¡æ¿çŠ¶æ€ ==================
            const [promptParts, setPromptParts] = useState({ ...DEFAULT_PROMPT_PARTS });
            const [showPromptSettings, setShowPromptSettings] = useState(false);
            const [promptPresets, setPromptPresets] = useState([]);
            const [currentPresetId, setCurrentPresetId] = useState(null);
            const [showPresetNameInput, setShowPresetNameInput] = useState(false);
            const [newPresetName, setNewPresetName] = useState('');
            const [editingPromptPart, setEditingPromptPart] = useState(null);

            // ================== OC ç³»ç»ŸçŠ¶æ€ ==================
            const [ocCollections, setOcCollections] = useState(() => {
                const saved = localStorage.getItem('sd_oc_collections');
                if (saved) { try { return JSON.parse(saved); } catch(e) {} }
                return [{ ...DEFAULT_OC_COLLECTION, id: generateId() }];
            });
            const [currentCollectionId, setCurrentCollectionId] = useState(() => {
                return localStorage.getItem('sd_current_collection_id') || null;
            });
            const [ocEnabled, setOcEnabled] = useState(() => {
                return localStorage.getItem('sd_oc_enabled') === 'true';
            });
            const [showOcEditor, setShowOcEditor] = useState(false);
            const [editingOc, setEditingOc] = useState(null);
            const [showCollectionDropdown, setShowCollectionDropdown] = useState(false);
            const [editingCollectionName, setEditingCollectionName] = useState(null);
            const [newCollectionName, setNewCollectionName] = useState('');
            const [hoveredOcId, setHoveredOcId] = useState(null);

            // ================== OC æ‹–æ‹½æ’åºçŠ¶æ€ ==================
            const [ocDragMode, setOcDragMode] = useState(false);
            const [ocDragData, setOcDragData] = useState(null);
            const [ocDropTarget, setOcDropTarget] = useState(null);

            // ================== å†å²è®°å½•çŠ¶æ€ ==================
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const isHistoryAction = useRef(false);
            const actionSource = useRef('manual');

            // ================== UI äº¤äº’çŠ¶æ€ ==================
            const [toasts, setToasts] = useState([]);
            const [confirmModal, setConfirmModal] = useState({ show: false, title: "", message: "", onConfirm: null });
            const [selectedTagIds, setSelectedTagIds] = useState(new Set());
            const [editingTagId, setEditingTagId] = useState(null);
            const [hoveredTagId, setHoveredTagId] = useState(null);
            const [showCopyFeedback, setShowCopyFeedback] = useState(false);
            const [slotCopyFeedback, setSlotCopyFeedback] = useState(null);
            const [smartPasteContent, setSmartPasteContent] = useState('');
            const [isSmartParsing, setIsSmartParsing] = useState(false);

            // ================== SD/NAI 9å®«æ ¼æ‹–æ‹½çŠ¶æ€ ==================
            const [dragData, setDragData] = useState(null);
            const [dropTarget, setDropTarget] = useState(null);

            // ================== å¯¼å…¥å¯¼å‡ºé€‰é¡¹ ==================
            const [exportOptions, setExportOptions] = useState({
                apiConfig: true, apiKeys: false, ocData: true,
                promptParts: true, promptPresets: true, currentSlots: true
            });

            // ================== Refs ==================
            const editInputRef = useRef(null);
            const slotInputRefs = useRef({});
            const scrollRefs = useRef({});
            const isScrolling = useRef({});
            const scrollTimeouts = useRef({});
            const fileInputRef = useRef(null);
            const ocFileInputRef = useRef(null);
            const characterScrollRef = useRef(null);

            // ================== æ´¾ç”ŸçŠ¶æ€ ==================
            const currentCollection = useMemo(() =>
                ocCollections.find(c => c.id === currentCollectionId) || ocCollections[0],
                [ocCollections, currentCollectionId]
            );
            const currentCharacters = useMemo(() => currentCollection?.characters || [], [currentCollection]);

            // åˆ¤æ–­æ˜¯å¦ä¸º NewBie æ¨¡å¼
            const isNewbieMode = promptMode === 'newbie';

            // åˆ¤æ–­æ˜¯å¦ä¸º NAI åˆ†è§’è‰²æ¨¡å¼
            const isNaiMultiMode = promptMode === 'nai' && naiMultiMode;

            // è·å–å½“å‰æ¨¡å¼çš„æ§½ä½é…ç½®
            const currentSlotConfig = useMemo(() => {
                return isNewbieMode ? SLOT_CONFIG_NEWBIE_GENERAL : SLOT_CONFIG_STANDARD;
            }, [isNewbieMode]);


            // ================== åˆå§‹åŒ– ==================
            useEffect(() => {
                // åˆå§‹åŒ– SD/NAI æ ‡å‡†æ§½ä½ï¼ˆ9å®«æ ¼ï¼‰
                const savedSlots = localStorage.getItem('sd_gacha_slots');
                let loadedSlots = null;
                if (savedSlots) {
                    try { loadedSlots = JSON.parse(savedSlots); } catch(e) {}
                }

                const finalSlots = {};
                SLOT_CONFIG_STANDARD.forEach(config => {
                    if (loadedSlots && loadedSlots[config.id]) {
                        finalSlots[config.id] = loadedSlots[config.id];
                    } else {
                        finalSlots[config.id] = {
                            tags: config.id === 'quality' ? [...INITIAL_QUALITY_TAGS] : [],
                            locked: config.id === 'quality',
                            included: true
                        };
                    }
                });

                // å…¼å®¹æ—§ç‰ˆ artist æ§½ä½åˆå¹¶åˆ° quality
                if (loadedSlots && loadedSlots.artist && loadedSlots.artist.tags && loadedSlots.artist.tags.length > 0) {
                    finalSlots.quality.tags = [...finalSlots.quality.tags, ...loadedSlots.artist.tags];
                }
                setSlots(finalSlots);

                // åˆå§‹åŒ– NewBie é€šç”¨æ§½ä½
                const savedNewbieGeneral = localStorage.getItem('sd_newbie_general_slots');
                let loadedNewbieGeneral = null;
                if (savedNewbieGeneral) {
                    try { loadedNewbieGeneral = JSON.parse(savedNewbieGeneral); } catch(e) {}
                }

                const finalNewbieGeneral = {};
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(config => {
                    if (loadedNewbieGeneral && loadedNewbieGeneral[config.id]) {
                        finalNewbieGeneral[config.id] = loadedNewbieGeneral[config.id];
                    } else {
                        const initialTags = config.id === 'nb_quality' ? [
                            { id: generateId(), en: 'masterpiece', zh: 'æ°ä½œ', category: 'quality' },
                            { id: generateId(), en: 'best_quality', zh: 'æœ€ä½³è´¨é‡', category: 'quality' },
                            { id: generateId(), en: 'highres', zh: 'é«˜åˆ†è¾¨ç‡', category: 'resolution' },
                            { id: generateId(), en: 'anime_style', zh: 'åŠ¨æ¼«é£æ ¼', category: 'style' },
                        ] : [];
                        finalNewbieGeneral[config.id] = {
                            tags: initialTags,
                            locked: config.id === 'nb_quality',
                            included: true
                        };
                    }
                });
                setNewbieGeneralSlots(finalNewbieGeneral);

                // åˆå§‹åŒ– NewBie è§’è‰²æ§½ä½
                const savedNewbieCharacters = localStorage.getItem('sd_newbie_character_slots');
                let loadedNewbieCharacters = null;
                if (savedNewbieCharacters) {
                    try { loadedNewbieCharacters = JSON.parse(savedNewbieCharacters); } catch(e) {}
                }

                const finalNewbieCharacters = {};
                NEWBIE_CHARACTER_SLOTS.forEach(charConfig => {
                    if (loadedNewbieCharacters && loadedNewbieCharacters[charConfig.id]) {
                        finalNewbieCharacters[charConfig.id] = loadedNewbieCharacters[charConfig.id];
                    } else {
                        finalNewbieCharacters[charConfig.id] = { tags: [] };
                    }
                });
                setNewbieCharacterSlots(finalNewbieCharacters);

                // åˆå§‹åŒ– NAI åˆ†è§’è‰²æ¨¡å¼åŸºç¡€æ§½ä½ï¼ˆå¤ç”¨ SLOT_CONFIG_NEWBIE_GENERAL é…ç½®ï¼‰
                const savedNaiMultiBase = localStorage.getItem('sd_nai_multi_base_slots');
                let loadedNaiMultiBase = null;
                if (savedNaiMultiBase) {
                    try { loadedNaiMultiBase = JSON.parse(savedNaiMultiBase); } catch(e) {}
                }

                const finalNaiMultiBase = {};
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(config => {
                    if (loadedNaiMultiBase && loadedNaiMultiBase[config.id]) {
                        finalNaiMultiBase[config.id] = loadedNaiMultiBase[config.id];
                    } else {
                        const initialTags = config.id === 'nb_quality' ? [
                            { id: generateId(), en: 'masterpiece', zh: 'æ°ä½œ', category: 'quality' },
                            { id: generateId(), en: 'best quality', zh: 'æœ€ä½³è´¨é‡', category: 'quality' },
                        ] : [];
                        finalNaiMultiBase[config.id] = {
                            tags: initialTags,
                            locked: config.id === 'nb_quality',
                            included: true
                        };
                    }
                });
                setNaiMultiBaseSlots(finalNaiMultiBase);

                // åˆå§‹åŒ– NAI åˆ†è§’è‰²æ¨¡å¼è§’è‰²æ§½ä½ï¼ˆå¤ç”¨ NEWBIE_CHARACTER_SLOTS é…ç½®ï¼‰
                const savedNaiMultiChars = localStorage.getItem('sd_nai_multi_char_slots');
                let loadedNaiMultiChars = null;
                if (savedNaiMultiChars) {
                    try { loadedNaiMultiChars = JSON.parse(savedNaiMultiChars); } catch(e) {}
                }

                const finalNaiMultiChars = {};
                NEWBIE_CHARACTER_SLOTS.forEach(charConfig => {
                    if (loadedNaiMultiChars && loadedNaiMultiChars[charConfig.id]) {
                        finalNaiMultiChars[charConfig.id] = loadedNaiMultiChars[charConfig.id];
                    } else {
                        finalNaiMultiChars[charConfig.id] = { tags: [] };
                    }
                });
                setNaiMultiCharSlots(finalNaiMultiChars);

                // åŠ è½½ API é…ç½®
                const savedProvider = localStorage.getItem('sd_api_provider');
                if (savedProvider && API_PROVIDERS[savedProvider]) {
                    setApiProvider(savedProvider);
                    setCurrentBaseUrl(localStorage.getItem(`sd_api_base_${savedProvider}`) || API_PROVIDERS[savedProvider].defaultBaseUrl);
                    setCurrentModel(localStorage.getItem(`sd_api_model_${savedProvider}`) || API_PROVIDERS[savedProvider].defaultModel);
                }

                const savedApiKeys = localStorage.getItem('sd_api_keys');
                if (savedApiKeys) try { setApiKeys(JSON.parse(savedApiKeys)); } catch(e) {}

                // åŠ è½½æç¤ºè¯æ¨¡æ¿
                const savedPromptParts = localStorage.getItem('sd_prompt_parts');
                if (savedPromptParts) try { setPromptParts(JSON.parse(savedPromptParts)); } catch(e) {}

                const savedPresets = localStorage.getItem('sd_prompt_presets');
                if (savedPresets) try { setPromptPresets(JSON.parse(savedPresets)); } catch(e) {}

                const savedCurrentPreset = localStorage.getItem('sd_current_preset_id');
                if (savedCurrentPreset) setCurrentPresetId(savedCurrentPreset);

                // åŠ è½½å†å²è®°å½•
                const savedHistory = localStorage.getItem('sd_history_log');
                if (savedHistory) try {
                    const h = JSON.parse(savedHistory);
                    setHistory(h);
                    setHistoryIndex(h.length - 1);
                } catch(e) {}
            }, []);

            // ================== æŒä¹…åŒ– ==================
            // SD/NAI æ§½ä½
            useEffect(() => {
                if (Object.keys(slots).length > 0)
                    localStorage.setItem('sd_gacha_slots', JSON.stringify(slots));
            }, [slots]);

            // NewBie é€šç”¨æ§½ä½
            useEffect(() => {
                if (Object.keys(newbieGeneralSlots).length > 0)
                    localStorage.setItem('sd_newbie_general_slots', JSON.stringify(newbieGeneralSlots));
            }, [newbieGeneralSlots]);

            // NewBie è§’è‰²æ§½ä½
            useEffect(() => {
                if (Object.keys(newbieCharacterSlots).length > 0)
                    localStorage.setItem('sd_newbie_character_slots', JSON.stringify(newbieCharacterSlots));
            }, [newbieCharacterSlots]);

            // NAI åˆ†è§’è‰²æ¨¡å¼æŒä¹…åŒ–
            useEffect(() => { 
                localStorage.setItem('sd_nai_multi_mode', naiMultiMode.toString()); 
            }, [naiMultiMode]);
            
            useEffect(() => {
                if (Object.keys(naiMultiBaseSlots).length > 0)
                    localStorage.setItem('sd_nai_multi_base_slots', JSON.stringify(naiMultiBaseSlots));
            }, [naiMultiBaseSlots]);
            
            useEffect(() => {
                if (Object.keys(naiMultiCharSlots).length > 0)
                    localStorage.setItem('sd_nai_multi_char_slots', JSON.stringify(naiMultiCharSlots));
            }, [naiMultiCharSlots]);

            // å…¶ä»–çŠ¶æ€æŒä¹…åŒ–
            useEffect(() => { localStorage.setItem('sd_prompt_mode', promptMode); }, [promptMode]);
            useEffect(() => { localStorage.setItem('sd_api_provider', apiProvider); }, [apiProvider]);
            useEffect(() => { localStorage.setItem('sd_api_keys', JSON.stringify(apiKeys)); }, [apiKeys]);
            useEffect(() => { localStorage.setItem('sd_api_timeout', apiTimeout); }, [apiTimeout]);
            useEffect(() => { localStorage.setItem('sd_api_retries', apiRetries); }, [apiRetries]);
            useEffect(() => { localStorage.setItem('sd_temperature', temperature); }, [temperature]);
            useEffect(() => { localStorage.setItem('sd_top_p', topP); }, [topP]);
            useEffect(() => { localStorage.setItem('sd_frequency_penalty', frequencyPenalty); }, [frequencyPenalty]);
            useEffect(() => { localStorage.setItem('sd_presence_penalty', presencePenalty); }, [presencePenalty]);
            useEffect(() => { localStorage.setItem('sd_oc_collections', JSON.stringify(ocCollections)); }, [ocCollections]);
            useEffect(() => { if (currentCollectionId) localStorage.setItem('sd_current_collection_id', currentCollectionId); }, [currentCollectionId]);
            useEffect(() => { localStorage.setItem('sd_oc_enabled', ocEnabled.toString()); }, [ocEnabled]);
            useEffect(() => { localStorage.setItem('sd_prompt_parts', JSON.stringify(promptParts)); }, [promptParts]);
            useEffect(() => { localStorage.setItem('sd_prompt_presets', JSON.stringify(promptPresets)); }, [promptPresets]);
            useEffect(() => { if (currentPresetId) localStorage.setItem('sd_current_preset_id', currentPresetId); }, [currentPresetId]);
            useEffect(() => { localStorage.setItem('sd_sidebar_open', isSidebarOpen.toString()); }, [isSidebarOpen]);
            useEffect(() => { localStorage.setItem('sd_active_tab', activeSidebarTab); }, [activeSidebarTab]);
            useEffect(() => { localStorage.setItem('sd_theme_input', themeInput); }, [themeInput]);
            useEffect(() => { localStorage.setItem('sd_generation_mode', generationMode); }, [generationMode]);
            useEffect(() => { localStorage.setItem('sd_keep_memory', keepMemory.toString()); }, [keepMemory]);
            useEffect(() => { localStorage.setItem('sd_oc_panel_open', ocPanelOpen.toString()); }, [ocPanelOpen]);
            useEffect(() => { localStorage.setItem('sd_conversation_history', JSON.stringify(conversationHistory)); }, [conversationHistory]);
            useEffect(() => { localStorage.setItem('sd_personal_mode', personalMode); }, [personalMode]);
            useEffect(() => { localStorage.setItem('sd_user_preferences', userPreferences); }, [userPreferences]);
            useEffect(() => { localStorage.setItem('sd_web_search_mode', webSearchMode); }, [webSearchMode]);
            useEffect(() => { localStorage.setItem('sd_web_search_prompt', webSearchPrompt); }, [webSearchPrompt]);
            useEffect(() => { localStorage.setItem('sd_web_search_result', webSearchResult); }, [webSearchResult]);
            useEffect(() => { localStorage.setItem('sd_web_search_favorites', JSON.stringify(webSearchFavorites)); }, [webSearchFavorites]);
            useEffect(() => { localStorage.setItem('sd_last_theme', lastTheme); }, [lastTheme]);

            // ç¡®ä¿æœ‰é»˜è®¤æ–‡ä»¶é›†
            useEffect(() => {
                if (!currentCollectionId && ocCollections.length > 0) {
                    setCurrentCollectionId(ocCollections[0].id);
                }
            }, [ocCollections, currentCollectionId]);

            // ================== Toast é€šçŸ¥ ==================
            const showToast = useCallback((message, type = "info") => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 3000);
            }, []);

            // ================== æ¨¡å¼åˆ‡æ¢ ==================
            const switchPromptMode = (newMode) => {
                setPromptMode(newMode);
                setPromptParts(prev => ({
                    ...prev,
                    main: newMode === 'nai' ? DEFAULT_NAI_MAIN
                        : newMode === 'newbie' ? DEFAULT_NEWBIE_MAIN
                        : DEFAULT_SD_MAIN
                }));
                setShowModeDropdown(false);
                const modeName = PROMPT_MODES[newMode]?.fullName || newMode;
                showToast(`å·²åˆ‡æ¢åˆ° ${modeName} æ¨¡å¼`, "success");
            };


            // ================== CORS ä»£ç†é…ç½® ==================
            const CORS_PROXIES = [
                { name: 'ç›´è¿ (Direct)', url: '', encode: false },
                { name: 'corsproxy.io', url: 'https://corsproxy.io/?', encode: true },
                { name: 'CodeTabs', url: 'https://api.codetabs.com/v1/proxy?quest=', encode: true },
                { name: 'AllOrigins', url: 'https://api.allorigins.win/raw?url=', encode: true },
                { name: 'cors.eu.org', url: 'https://cors.eu.org/', encode: false },
            ];


            const currentProxyIndexRef = useRef(0);
            const proxyFailCountRef = useRef({});

            const getProxiedUrl = (targetUrl) => {
                const proxy = CORS_PROXIES[currentProxyIndexRef.current];
                if (!proxy.url) return targetUrl;
                return proxy.encode ? proxy.url + encodeURIComponent(targetUrl) : proxy.url + targetUrl;
            };

            const switchToNextProxy = () => {
                const oldProxy = CORS_PROXIES[currentProxyIndexRef.current];
                currentProxyIndexRef.current = (currentProxyIndexRef.current + 1) % CORS_PROXIES.length;
                const newProxy = CORS_PROXIES[currentProxyIndexRef.current];
                showToast(`ä»£ç† ${oldProxy.name} ä¸ç¨³å®šï¼Œåˆ‡æ¢åˆ° ${newProxy.name}`, "warning");
                return newProxy;
            };

            const resetProxyIndex = () => {
                currentProxyIndexRef.current = 0;
                proxyFailCountRef.current = {};
            };

            // ================== API è°ƒç”¨ ==================
            const callLLM = async (messages) => {
                let lastError = null;
                const maxAttempts = apiRetries > 0 ? apiRetries + 1 : 1;
                const maxProxyAttempts = CORS_PROXIES.length;
                let proxyAttempts = 0;

                while (proxyAttempts < maxProxyAttempts) {
                    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), apiTimeout);

                        try {
                            if (attempt > 1) setLoadingText(`è¶…æ—¶é‡è¯•ä¸­ (${attempt - 1}/${apiRetries})...`);
                            if (proxyAttempts > 0) setLoadingText(`å°è¯•ä»£ç† ${CORS_PROXIES[currentProxyIndexRef.current].name}...`);

                            const targetUrl = `${currentBaseUrl}/chat/completions`;
                            const fetchUrl = getProxiedUrl(targetUrl);

                            const response = await fetch(fetchUrl, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKeys[apiProvider]}`
                                },
                                body: JSON.stringify({
                                    model: currentModel,
                                    messages,
                                    temperature,
                                    top_p: topP,
                                    frequency_penalty: frequencyPenalty,
                                    presence_penalty: presencePenalty,
                                    max_tokens: 8192
                                }),
                                signal: controller.signal
                            });

                            clearTimeout(timeoutId);

                            if (!response.ok) {
                                const err = await response.json().catch(() => ({}));
                                throw new Error(err.error?.message || `API é”™è¯¯: ${response.status}`);
                            }
                            const data = await response.json();
                            proxyFailCountRef.current[currentProxyIndexRef.current] = 0;
                            return data.choices[0].message.content;

                        } catch (e) {
                            clearTimeout(timeoutId);
                            lastError = e;

                            const isTimeout = e.name === 'AbortError';
                            const isNetworkError = e.message.includes('fetch') || e.message.includes('network') || e.message.includes('Failed');
                            const isCorsError = e.message.includes('CORS') || e.message.includes('cross-origin') || e.message.includes('NetworkError');

                            if (isCorsError || (isNetworkError && attempt === maxAttempts)) {
                                proxyFailCountRef.current[currentProxyIndexRef.current] = (proxyFailCountRef.current[currentProxyIndexRef.current] || 0) + 1;
                                if (proxyFailCountRef.current[currentProxyIndexRef.current] >= 2) {
                                    switchToNextProxy();
                                    proxyAttempts++;
                                    break;
                                }
                            }

                            if ((isTimeout || isNetworkError) && attempt < maxAttempts) continue;

                            if (attempt === maxAttempts && proxyAttempts < maxProxyAttempts - 1) {
                                switchToNextProxy();
                                proxyAttempts++;
                                break;
                            }
                            throw e;
                        }
                    }
                }
                throw lastError || new Error("æ‰€æœ‰ä»£ç†å‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é…ç½®");
            };

            // ================== æµ‹è¯• API è¿æ¥ ==================
            const testApiConnection = async () => {
                if (!apiKeys[apiProvider]) {
                    showToast("è¯·å…ˆè¾“å…¥ API Key", "warning");
                    return;
                }
                setIsTestingConnection(true);
                setApiError(null);

                let lastError = null;
                for (let proxyIdx = 0; proxyIdx < CORS_PROXIES.length; proxyIdx++) {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), apiTimeout);

                        const targetUrl = `${currentBaseUrl}/chat/completions`;
                        const fetchUrl = getProxiedUrl(targetUrl);

                        const response = await fetch(fetchUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKeys[apiProvider]}`
                            },
                            body: JSON.stringify({
                                model: currentModel,
                                messages: [{ role: "user", content: "Hi" }],
                                max_tokens: 5
                            }),
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            const err = await response.json().catch(() => ({}));
                            throw new Error(err.error?.message || `API é”™è¯¯: ${response.status}`);
                        }

                        setApiConnected(true);
                        showToast(`API è¿æ¥æˆåŠŸï¼(${CORS_PROXIES[currentProxyIndexRef.current].name})`, "success");
                        setIsTestingConnection(false);
                        return;

                    } catch (e) {
                        lastError = e;
                        const isCorsOrNetwork = e.name === 'AbortError' || e.message.includes('fetch') || e.message.includes('CORS') || e.message.includes('NetworkError') || e.message.includes('Failed');
                        if (isCorsOrNetwork && proxyIdx < CORS_PROXIES.length - 1) {
                            switchToNextProxy();
                            continue;
                        }
                    }
                }

                const errorMsg = lastError?.name === 'AbortError' ? 'è¿æ¥è¶…æ—¶' : lastError?.message || 'æœªçŸ¥é”™è¯¯';
                setApiError(errorMsg);
                setApiConnected(false);
                showToast("æ‰€æœ‰ä»£ç†å‡è¿æ¥å¤±è´¥: " + errorMsg, "error");
                setIsTestingConnection(false);
            };

            // ================== è·å–æ¨¡å‹åˆ—è¡¨ ==================
            const fetchModelList = async () => {
                if (!apiKeys[apiProvider]) {
                    showToast("è¯·å…ˆè¾“å…¥ API Key", "warning");
                    return;
                }
                setIsLoadingModels(true);

                try {
                    const targetUrl = `${currentBaseUrl}/models`;
                    const fetchUrl = getProxiedUrl(targetUrl);
                    const response = await fetch(fetchUrl, {
                        headers: { 'Authorization': `Bearer ${apiKeys[apiProvider]}` }
                    });

                    if (!response.ok) throw new Error('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥');

                    const data = await response.json();
                    const models = data.data?.map(m => m.id) || [];
                    setAvailableModels(models);
                    if (models.length > 0) showToast(`è·å–åˆ° ${models.length} ä¸ªæ¨¡å‹`, "success");
                } catch (e) {
                    showToast("è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥", "error");
                } finally {
                    setIsLoadingModels(false);
                }
            };

            // ================== API é…ç½®å˜æ›´å¤„ç† ==================
            const handleProviderChange = (providerId) => {
                setApiProvider(providerId);
                const savedUrl = localStorage.getItem(`sd_api_base_${providerId}`);
                const savedModel = localStorage.getItem(`sd_api_model_${providerId}`);
                setCurrentBaseUrl(savedUrl || API_PROVIDERS[providerId].defaultBaseUrl);
                setCurrentModel(savedModel || API_PROVIDERS[providerId].defaultModel);
                setApiConnected(false);
                setAvailableModels([]);
                resetProxyIndex();
            };

            const handleApiKeyChange = (key) => {
                setApiKeys(prev => ({ ...prev, [apiProvider]: key }));
                setApiConnected(false);
            };

            const handleBaseUrlChange = (url) => {
                setCurrentBaseUrl(url);
                localStorage.setItem(`sd_api_base_${apiProvider}`, url);
                setApiConnected(false);
                resetProxyIndex();
            };

            const handleModelChange = (model) => {
                setCurrentModel(model);
                localStorage.setItem(`sd_api_model_${apiProvider}`, model);
            };

            // ================== è§£æå‡½æ•°ï¼šSD/NAI å•äººæ¨¡å¼ï¼ˆ9å®«æ ¼ï¼‰==================
            const parseStandardPrompt = (text) => {
                const result = {};
                SLOT_CONFIG_STANDARD.forEach(c => result[c.id] = []);

                let cleanedText = text
                    .replace(/<thinking>[\s\S]*?<\/thinking>/gi, '')
                    .replace(/<Think>[\s\S]*?<\/Think>/gi, '')
                    .replace(/[\s\S]*?<\/think>/gi, '');

                const promptMatch = cleanedText.match(/<æç¤ºè¯>([\s\S]*?)<\/æç¤ºè¯>/);
                const contentToParse = promptMatch ? promptMatch[1] : cleanedText;

                const categoryMap = {
                    'quality': ['quality', 'è´¨é‡', 'ç”»è´¨', 'è´¨é‡&ç”»å¸ˆ', 'ç”»å¸ˆ', 'artist', 'è‰ºæœ¯å®¶'],
                    'character': ['character', 'è§’è‰²', 'äººç‰©'],
                    'expression': ['expression', 'è¡¨æƒ…', 'ç¥æƒ…'],
                    'appearance': ['appearance', 'å¤–è²Œ', 'å¤–è§‚', 'å®¹è²Œ'],
                    'clothing': ['clothing', 'æœè£…', 'è¡£æœ', 'æœé¥°'],
                    'action': ['action', 'åŠ¨ä½œ', 'å§¿åŠ¿', 'è¡Œä¸º'],
                    'items': ['items', 'item', 'ç‰©å“', 'é“å…·'],
                    'scene': ['scene', 'åœºæ™¯', 'èƒŒæ™¯', 'ç¯å¢ƒ'],
                    'composition': ['composition', 'æ„å›¾', 'è§†è§’']
                };

                let currentCategory = null;
                const lines = contentToParse.split('\n');

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;

                    const categoryMatch = trimmedLine.match(/^\[([^\]]+)\]/) ||
                                         trimmedLine.match(/^ã€([^ã€‘]+)ã€‘/) ||
                                         trimmedLine.match(/^##?\s*\[?([^\]\s]+)\]?/);
                    if (categoryMatch) {
                        const catName = categoryMatch[1].toLowerCase();
                        for (const [key, aliases] of Object.entries(categoryMap)) {
                            if (aliases.some(a => catName.includes(a.toLowerCase()))) {
                                currentCategory = key;
                                break;
                            }
                        }
                        continue;
                    }

                    if (currentCategory && result[currentCategory]) {
                        const parts = trimmedLine.split(/\s*[|ï½œ\/]\s*/);
                        if (parts.length >= 1) {
                            const en = parts[0].trim().replace(/^[-*â€¢]\s*/, '');
                            const zh = parts[1]?.trim() || '?';
                            if (en && !en.match(/^\[/) && !en.match(/^#/)) {
                                result[currentCategory].push({ id: generateId(), en, zh });
                            }
                        }
                    }
                }
                return result;
            };

            // ================== è§£æå‡½æ•°ï¼šNewBie æ¨¡å¼ ==================
            const parseNewbiePrompt = (text) => {
                const result = { characters: {}, general: {} };
                NEWBIE_CHARACTER_SLOTS.forEach(c => result.characters[c.id] = []);
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(c => result.general[c.id] = []);

                let cleanedText = text
                    .replace(/<thinking>[\s\S]*?<\/thinking>/gi, '')
                    .replace(/<Think>[\s\S]*?<\/Think>/gi, '')
                    .replace(/[\s\S]*?<\/think>/gi, '');

                const promptMatch = cleanedText.match(/<æç¤ºè¯>([\s\S]*?)<\/æç¤ºè¯>/);
                const contentToParse = promptMatch ? promptMatch[1] : cleanedText;

                const slotMap = {
                    'char_1': 'char_1', 'char_2': 'char_2', 'char_3': 'char_3', 'char_4': 'char_4',
                    'character_1': 'char_1', 'character_2': 'char_2', 'character_3': 'char_3', 'character_4': 'char_4',
                    'nb_quality': 'nb_quality', 'nb_objects': 'nb_objects', 'nb_scene': 'nb_scene', 'nb_composition': 'nb_composition',
                    'quality': 'nb_quality', 'objects': 'nb_objects', 'scene': 'nb_scene', 'composition': 'nb_composition',
                };

                const categoryToSlot = {
                    'n': 'character', 'gender': 'character', 'appearance': 'character',
                    'expression': 'character', 'clothing': 'character', 'action': 'character', 'position': 'character',
                    'quality': 'nb_quality', 'resolution': 'nb_quality', 'style': 'nb_quality', 'artists': 'nb_quality',
                    'objects': 'nb_objects',
                    'background': 'nb_scene', 'atmosphere': 'nb_scene',
                    'lighting': 'nb_composition', 'perspective': 'nb_composition', 'other': 'nb_composition',
                };

                let currentSlotId = null;
                let isCharacterSlot = false;
                const lines = contentToParse.split('\n');

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;

                    const slotMatch = trimmedLine.match(/^\[([^\]]+)\]/);
                    if (slotMatch) {
                        const slotName = slotMatch[1].toLowerCase().trim();
                        currentSlotId = slotMap[slotName] || null;
                        isCharacterSlot = currentSlotId?.startsWith('char_');
                        continue;
                    }

                    if (!currentSlotId) continue;

                    const categoryMatch = trimmedLine.match(/^(\w+):\s*(.*)$/);
                    if (categoryMatch) {
                        const categoryId = categoryMatch[1].toLowerCase();
                        const content = categoryMatch[2].trim();
                        if (!content || content === '|') continue;

                        const [tagsStr, zhStr] = content.split('|').map(s => s?.trim() || '');
                        const tags = tagsStr.split(',').map(t => t.trim()).filter(t => t);
                        const zhs = zhStr ? zhStr.split(',').map(z => z.trim()) : [];

                        tags.forEach((tag, idx) => {
                            const tagObj = { id: generateId(), en: tag, zh: zhs[idx] || '?', category: categoryId };
                            if (isCharacterSlot) {
                                result.characters[currentSlotId].push(tagObj);
                            } else {
                                const targetSlot = categoryToSlot[categoryId] || currentSlotId;
                                if (result.general[targetSlot]) {
                                    result.general[targetSlot].push(tagObj);
                                }
                            }
                        });
                    }
                }
                return result;
            };

            // ================== è§£æå‡½æ•°ï¼šNAI åˆ†è§’è‰²æ¨¡å¼ï¼ˆå¤ç”¨ NewBie ç»“æ„ï¼‰==================
            const parseNaiMultiPrompt = (text) => {
                const result = { base: {}, characters: {} };
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(c => result.base[c.id] = []);
                NEWBIE_CHARACTER_SLOTS.forEach(c => result.characters[c.id] = []);

                let cleanedText = text
                    .replace(/<thinking>[\s\S]*?<\/thinking>/gi, '')
                    .replace(/<Think>[\s\S]*?<\/Think>/gi, '')
                    .replace(/[\s\S]*?<\/think>/gi, '');

                const promptMatch = cleanedText.match(/<æç¤ºè¯>([\s\S]*?)<\/æç¤ºè¯>/);
                const contentToParse = promptMatch ? promptMatch[1] : cleanedText;

                // æ§½ä½æ˜ å°„ï¼ˆä¸ NewBie ä¸€è‡´ï¼‰
                const slotMap = {
                    'base': 'nb_scene', 'nai_base': 'nb_scene',
                    'quality': 'nb_quality', 'nai_quality': 'nb_quality',
                    'nb_quality': 'nb_quality', 'nb_objects': 'nb_objects', 'nb_scene': 'nb_scene', 'nb_composition': 'nb_composition',
                    'char_1': 'char_1', 'char_2': 'char_2', 'char_3': 'char_3', 'char_4': 'char_4',
                    'scene': 'nb_scene', 'composition': 'nb_composition', 'objects': 'nb_objects',
                };

                // ç±»åˆ«æ˜ å°„
                const categoryMap = {
                    'quality': 'quality', 'style': 'style', 'artists': 'artists', 'resolution': 'resolution',
                    'count': 'background', 'scene': 'background', 'mood': 'atmosphere', 'background': 'background', 'atmosphere': 'atmosphere',
                    'objects': 'objects',
                    'lighting': 'lighting', 'perspective': 'perspective', 'other': 'other',
                    'type': 'gender', 'identity': 'n', 'appearance': 'appearance',
                    'expression': 'expression', 'clothing': 'clothing', 'action': 'action', 'position': 'position',
                    'n': 'n', 'gender': 'gender',
                };

                let currentSlotId = null;
                let isCharacterSlot = false;
                const lines = contentToParse.split('\n');

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;

                    const slotMatch = trimmedLine.match(/^\[([^\]]+)\]/);
                    if (slotMatch) {
                        const slotName = slotMatch[1].toLowerCase().trim();
                        currentSlotId = slotMap[slotName] || null;
                        isCharacterSlot = currentSlotId?.startsWith('char_');
                        continue;
                    }

                    if (!currentSlotId) continue;

                    // å°è¯•è§£æ category: tags|ä¸­æ–‡ æ ¼å¼
                    const categoryMatch = trimmedLine.match(/^(\w+):\s*(.*)$/);
                    let tagsContent = trimmedLine;
                    let categoryId = null;

                    if (categoryMatch) {
                        categoryId = categoryMap[categoryMatch[1].toLowerCase()] || categoryMatch[1].toLowerCase();
                        tagsContent = categoryMatch[2].trim();
                    }

                    if (!tagsContent || tagsContent === '|') continue;

                    const [tagsStr, zhStr] = tagsContent.split('|').map(s => s?.trim() || '');
                    const tags = tagsStr.split(',').map(t => t.trim()).filter(t => t);
                    const zhs = zhStr ? zhStr.split(',').map(z => z.trim()) : [];

                    tags.forEach((tag, idx) => {
                        const tagObj = {
                            id: generateId(),
                            en: tag,
                            zh: zhs[idx] || '?',
                            category: categoryId || (isCharacterSlot ? 'appearance' : 'background')
                        };

                        if (isCharacterSlot) {
                            result.characters[currentSlotId].push(tagObj);
                        } else if (result.base[currentSlotId]) {
                            result.base[currentSlotId].push(tagObj);
                        }
                    });
                }
                return result;
            };


            // ================== OC ä¸Šä¸‹æ–‡æ„å»º ==================
            const buildOcContext = () => {
                if (!ocEnabled) return { context: '', hasOC: false };

                const enabledOCs = currentCharacters.filter(oc => oc.enabled);
                if (enabledOCs.length === 0) return { context: '', hasOC: false };

                let context = `\n\n## ğŸ“Œ OC Character Data (MUST USE!)

âš ï¸ **CRITICAL OC RULES**:
1. Copy OC tags EXACTLY as provided - DO NOT modify!
2. Only allowed change: convert weight format if needed (SD â†” NAI)
3. Each OC is wrapped in their own tag to prevent feature mixing!

`;
                enabledOCs.forEach((oc, index) => {
                    context += `<OCè§’è‰²:${oc.name}>\n`;
                    context += `### OC ${index + 1}: ${oc.name}\n`;
                    context += `**Core Features**:\n\`\`\`\n${oc.core}\n\`\`\`\n`;
                    
                    const ocOutfits = oc.outfits?.filter(o => o.enabled) || [];
                    if (ocOutfits.length > 0) {
                        context += `**Selected Outfits**:\n`;
                        ocOutfits.forEach(outfit => {
                            context += `- [${outfit.name}]: \`${outfit.tags}\`\n`;
                        });
                    }
                    context += `</OCè§’è‰²:${oc.name}>\n\n`;
                });

                if (enabledOCs.length > 1) {
                    context += `âš ï¸ **MULTIPLE OC WARNING**: DO NOT mix features between different OCs!\n`;
                }

                return { context, hasOC: true };
            };

            // ================== è”ç½‘æ£€ç´¢ä¸Šä¸‹æ–‡æ„å»º ==================
            const buildWebSearchContext = (theme = '') => {
                if (webSearchMode === 'off') return { context: '', hasWebSearch: false };

                let context = '';
                if (webSearchMode === 'on' && theme?.trim()) {
                    context = `\n\n## ğŸ” è”ç½‘æ£€ç´¢ä»»åŠ¡\n${webSearchPrompt}\n**è¯·æœç´¢çš„è§’è‰²ï¼š${theme}**\n`;
                } else if (webSearchMode === 'sendOnly' && webSearchResult.trim()) {
                    context = `\n\n## ğŸ” è”ç½‘æ£€ç´¢çš„è§’è‰²ç‰¹å¾ï¼ˆä¼˜å…ˆå‚è€ƒï¼‰\n${webSearchResult}\n`;
                }

                return { context, hasWebSearch: context.length > 0 };
            };

            // ================== æ ¸å¿ƒç”Ÿæˆå‡½æ•° ==================
            const callLLMGenerateRaw = async (theme, mode) => {
                const randomSeed = Math.random().toString(36).substring(7);

                const modeInstruction = mode === 'detailed'
                    ? `## ğŸ¨ Mode: DETAILED\n- Generate 30+ tags total\n- Be rich and descriptive`
                    : `## âš¡ Mode: CONCISE (STRICT)\n- Generate 15-20 tags MAXIMUM total\n- Focus on essential elements only`;

                let formatModeInstruction;
                if (isNewbieMode) {
                    formatModeInstruction = `## ğŸ¯ FORMAT: NewBie XML\n- NO weight format\n- Use underscores\n- Output: category: tags|ä¸­æ–‡`;
                } else if (isNaiMultiMode) {
                    formatModeInstruction = `## ğŸ¯ FORMAT: NAI 4.5 Multi-Character\n- Weight: 1.2::tag::\n- Use [nb_quality], [nb_scene], [char_1], [char_2] etc.\n- Use source#/target#/mutual# for interactions`;
                } else if (promptMode === 'nai') {
                    formatModeInstruction = `## ğŸ¯ FORMAT: NAI 4.5\n- Weight: 1.2::tag::\n- Spaces allowed`;
                } else {
                    formatModeInstruction = `## ğŸ¯ FORMAT: Stable Diffusion\n- Weight: (tag:1.2)\n- Use underscores, escape: \\(series\\)`;
                }

                const { context: ocContext, hasOC } = buildOcContext();
                const { context: webSearchContext, hasWebSearch } = buildWebSearchContext(theme);

                const messages = [];

                if (promptParts.top?.trim()) {
                    messages.push({ role: "system", content: promptParts.top });
                }

                if (keepMemory && conversationHistory.length > 0) {
                    messages.push(...conversationHistory);
                }

                let mainPrompt = modeInstruction + '\n\n' + formatModeInstruction + '\n\n' + promptParts.main;
                if (hasOC) mainPrompt += ocContext;
                messages.push({ role: "system", content: mainPrompt });

                let userPrompt = theme
                    ? `Theme: ${theme} [Seed: ${randomSeed}]`
                    : `Random creative anime illustration [Seed: ${randomSeed}]`;

                userPrompt += `\n\nâš ï¸ Format: ${isNaiMultiMode ? 'NAI Multi-Character' : promptMode === 'newbie' ? 'NewBie XML' : promptMode === 'nai' ? 'NAI 4.5' : 'SD'}`;

                if (hasOC) {
                    userPrompt += `\nUsing OC: ${currentCharacters.filter(oc => oc.enabled).map(oc => oc.name).join(', ')}`;
                }

                // æ§½ä½çŠ¶æ€
                const getLockedAndExcluded = () => {
                    if (isNewbieMode) {
                        const locked = SLOT_CONFIG_NEWBIE_GENERAL.filter(c => newbieGeneralSlots[c.id]?.locked).map(c => c.label);
                        const excluded = SLOT_CONFIG_NEWBIE_GENERAL.filter(c => !newbieGeneralSlots[c.id]?.included).map(c => c.label);
                        return { locked, excluded };
                    } else if (isNaiMultiMode) {
                        const locked = SLOT_CONFIG_NEWBIE_GENERAL.filter(c => naiMultiBaseSlots[c.id]?.locked).map(c => c.label);
                        const excluded = SLOT_CONFIG_NEWBIE_GENERAL.filter(c => !naiMultiBaseSlots[c.id]?.included).map(c => c.label);
                        return { locked, excluded };
                    } else {
                        const locked = SLOT_CONFIG_STANDARD.filter(c => slots[c.id]?.locked).map(c => c.label);
                        const excluded = SLOT_CONFIG_STANDARD.filter(c => !slots[c.id]?.included).map(c => c.label);
                        return { locked, excluded };
                    }
                };

                const { locked, excluded } = getLockedAndExcluded();
                if (locked.length > 0 || excluded.length > 0) {
                    userPrompt += `\n\nâš ï¸ SKIP: `;
                    if (locked.length > 0) userPrompt += `ğŸ”’ ${locked.join(', ')} `;
                    if (excluded.length > 0) userPrompt += `ğŸš« ${excluded.join(', ')}`;
                }

                if (personalMode !== 'off' && userPreferences.trim()) {
                    userPrompt += `\n\n<ç”¨æˆ·ç”»åƒ>\n${userPreferences}\n</ç”¨æˆ·ç”»åƒ>`;
                }

                messages.push({ role: "user", content: userPrompt });

                let suffixContent = '';
                if (promptParts.extra?.trim()) suffixContent += promptParts.extra;
                if (hasWebSearch) suffixContent += webSearchContext;
                if (promptParts.bottom?.trim()) suffixContent += '\n' + promptParts.bottom;
                if (suffixContent) messages.push({ role: "system", content: suffixContent });

                const response = await callLLM(messages);

                if (keepMemory) {
                    const promptMatch = response.match(/<æç¤ºè¯>([\s\S]*?)<\/æç¤ºè¯>/);
                    if (promptMatch) {
                        setConversationHistory(prev => [...prev,
                            { role: "user", content: theme || 'éšæœºä¸»é¢˜' },
                            { role: "assistant", content: `<æç¤ºè¯>${promptMatch[1]}</æç¤ºè¯>` }
                        ]);
                    }
                }

                return response;
            };

            // ================== è”ç½‘æ£€ç´¢ ==================
            const handleWebSearch = async () => {
                if (!apiKeys[apiProvider] || !webSearchQuery.trim()) {
                    showToast(!apiKeys[apiProvider] ? "è¯·å…ˆé…ç½® API Key" : "è¯·è¾“å…¥è§’è‰²åç§°", "warning");
                    return;
                }
                setIsWebSearching(true);
                try {
                    const result = await callLLM([
                        { role: "system", content: webSearchPrompt },
                        { role: "user", content: `è¯·æœç´¢å¹¶æ•´ç†ï¼š${webSearchQuery}` }
                    ]);
                    setWebSearchResult(result);
                    showToast("è”ç½‘æ£€ç´¢å®Œæˆï¼", "success");
                } catch (e) {
                    showToast("æ£€ç´¢å¤±è´¥: " + e.message, "error");
                } finally {
                    setIsWebSearching(false);
                }
            };

            const saveWebSearchToFavorites = () => {
                if (!webSearchResult.trim()) return showToast("æ²¡æœ‰å¯æ”¶è—çš„å†…å®¹", "warning");
                const nameMatch = webSearchResult.match(/ã€äººç‰©åç§°ã€‘([^\n]+)/);
                const name = nameMatch ? nameMatch[1].trim() : webSearchQuery || 'æœªçŸ¥è§’è‰²';
                setWebSearchFavorites(prev => [{ id: generateId(), name, content: webSearchResult, query: webSearchQuery, createdAt: new Date().toISOString() }, ...prev]);
                showToast(`å·²æ”¶è—ã€Œ${name}ã€`, "success");
            };

            const deleteWebSearchFavorite = (id) => {
                setWebSearchFavorites(prev => prev.filter(f => f.id !== id));
                showToast("å·²åˆ é™¤æ”¶è—", "success");
            };

            const loadFavoriteToResult = (fav) => {
                setWebSearchResult(fav.content);
                setWebSearchQuery(fav.query || '');
                setWebSearchTab('result');
                showToast(`å·²åŠ è½½ã€Œ${fav.name}ã€`, "success");
            };

            const toggleWebSearchMode = () => {
                const modes = ['off', 'on', 'sendOnly'];
                setWebSearchMode(modes[(modes.indexOf(webSearchMode) + 1) % 3]);
            };

            const togglePersonalMode = () => {
                const modes = ['off', 'summarize', 'sendOnly'];
                setPersonalMode(modes[(modes.indexOf(personalMode) + 1) % 3]);
            };

            // ================== ä¸ªæ€§åŒ–æ€»ç»“ ==================
            const getUserBehaviorData = useCallback(() => {
                if (!lastAISlots) return null;
                const kept = [], deleted = [], added = [];
                
                let targetSlots, lastSlots;
                if (isNewbieMode) {
                    targetSlots = { ...newbieGeneralSlots, ...newbieCharacterSlots };
                    lastSlots = lastAISlots;
                } else if (isNaiMultiMode) {
                    targetSlots = { ...naiMultiBaseSlots, ...naiMultiCharSlots };
                    lastSlots = lastAISlots;
                } else {
                    targetSlots = slots;
                    lastSlots = lastAISlots?.slots || lastAISlots;
                }

                Object.keys(lastSlots).forEach(key => {
                    const lastTags = lastSlots[key]?.tags || [];
                    const currentTags = targetSlots[key]?.tags || [];
                    const lastSet = new Set(lastTags.map(t => t.en));
                    const currentSet = new Set(currentTags.map(t => t.en));

                    lastTags.forEach(t => (currentSet.has(t.en) ? kept : deleted).push(t.en));
                    currentTags.forEach(t => { if (!lastSet.has(t.en)) added.push(t.en); });
                });

                return { kept, deleted, added, copied: hasCopied };
            }, [lastAISlots, slots, newbieGeneralSlots, newbieCharacterSlots, naiMultiBaseSlots, naiMultiCharSlots, hasCopied, isNewbieMode, isNaiMultiMode]);

            const summarizePreferences = async () => {
                if (personalMode !== 'summarize') return;
                const behavior = getUserBehaviorData();
                if (!behavior && !userPreferences.trim()) return;

                setIsSummarizing(true);
                try {
                    let prompt = `ä½ æ˜¯ç”¨æˆ·ç”»åƒåˆ†æå¸ˆã€‚æ‰¾å‡ºç”¨æˆ·çš„ã€é›·åŒºã€‘ï¼ˆåå¤åˆ é™¤çš„å¤§ç±»ï¼‰ï¼Œä¸è¦é™åˆ¶éšæœºæ€§ã€‚\n`;
                    if (behavior) prompt += `ä¿ç•™: ${behavior.kept.join(', ')}\nåˆ é™¤: ${behavior.deleted.join(', ')}\næ·»åŠ : ${behavior.added.join(', ')}`;
                    if (userPreferences.trim()) prompt += `\nä¹‹å‰ç”»åƒï¼š${userPreferences}`;

                    const response = await callLLM([
                        { role: "system", content: "åªæ‰¾é›·åŒºï¼Œå€¾å‘ç”¨æœ€å¼±è¡¨è¿°ã€‚" },
                        { role: "user", content: prompt }
                    ]);

                    const match = response.match(/<ç”¨æˆ·å–œå¥½>([\s\S]*?)<\/ç”¨æˆ·å–œå¥½>/);
                    if (match) {
                        setUserPreferences(match[1].trim());
                        showToast("å·²æ›´æ–°ä¸ªæ€§åŒ–å–œå¥½", "success");
                    }
                } catch (e) {
                    showToast("æ€»ç»“å¤±è´¥: " + e.message, "error");
                } finally {
                    setIsSummarizing(false);
                }
            };

            const clearMemory = async () => {
                if (personalMode === 'summarize') await summarizePreferences();
                setConversationHistory([]);
                localStorage.removeItem('sd_conversation_history');
                setLastAISlots(null);
                setHasCopied(false);
                showToast("å¯¹è¯è®°å¿†å·²æ¸…ç©º", "success");
            };

            // ================== æç¤ºè¯é¢„è®¾ç®¡ç† ==================
            const saveAsNewPreset = () => {
                const name = newPresetName.trim() || `é¢„è®¾ ${promptPresets.length + 1}`;
                const newPreset = { id: generateId(), name, createdAt: new Date().toISOString(), parts: { ...promptParts } };
                setPromptPresets(prev => [...prev, newPreset]);
                setCurrentPresetId(newPreset.id);
                setNewPresetName('');
                setShowPresetNameInput(false);
                showToast(`å·²ä¿å­˜é¢„è®¾ã€Œ${name}ã€`, "success");
            };

            const updateCurrentPreset = () => {
                if (!currentPresetId) return showToast("è¯·å…ˆé€‰æ‹©æˆ–åˆ›å»ºé¢„è®¾", "warning");
                setPromptPresets(prev => prev.map(p => p.id === currentPresetId ? { ...p, parts: { ...promptParts }, updatedAt: new Date().toISOString() } : p));
                showToast("é¢„è®¾å·²æ›´æ–°", "success");
            };

            const loadPreset = (presetId) => {
                const preset = promptPresets.find(p => p.id === presetId);
                if (preset) {
                    setPromptParts({ ...preset.parts });
                    setCurrentPresetId(presetId);
                    showToast(`å·²åŠ è½½é¢„è®¾ã€Œ${preset.name}ã€`, "success");
                }
            };

            const deletePreset = (presetId) => {
                const preset = promptPresets.find(p => p.id === presetId);
                setConfirmModal({
                    show: true, title: "åˆ é™¤é¢„è®¾", message: `ç¡®å®šåˆ é™¤ã€Œ${preset?.name}ã€ï¼Ÿ`,
                    onConfirm: () => {
                        setPromptPresets(prev => prev.filter(p => p.id !== presetId));
                        if (currentPresetId === presetId) setCurrentPresetId(null);
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("é¢„è®¾å·²åˆ é™¤", "success");
                    }
                });
            };

            const updatePromptPart = (part, value) => setPromptParts(prev => ({ ...prev, [part]: value }));

            const resetPromptPart = (part) => {
                setPromptParts(prev => ({
                    ...prev,
                    [part]: part === 'main' 
                        ? (promptMode === 'nai' ? DEFAULT_NAI_MAIN : promptMode === 'newbie' ? DEFAULT_NEWBIE_MAIN : DEFAULT_SD_MAIN)
                        : DEFAULT_PROMPT_PARTS[part]
                }));
                showToast("å·²é‡ç½®è¯¥éƒ¨åˆ†", "success");
            };

            const resetAllPromptParts = () => {
                setPromptParts({
                    ...DEFAULT_PROMPT_PARTS,
                    main: promptMode === 'nai' ? DEFAULT_NAI_MAIN : promptMode === 'newbie' ? DEFAULT_NEWBIE_MAIN : DEFAULT_SD_MAIN
                });
                showToast("å·²é‡ç½®å…¨éƒ¨æç¤ºè¯æ¨¡æ¿", "success");
            };

            const resetWebSearchPrompt = () => {
                setWebSearchPrompt(DEFAULT_WEB_SEARCH_PROMPT);
                showToast("å·²é‡ç½®è”ç½‘æ£€ç´¢æç¤ºè¯", "success");
            };

            // ================== Tag æ“ä½œ ==================
            const addTag = (slotId, rawText, category = null) => {
                if (!rawText) return;
                const newTags = rawText.split(/[,ï¼Œ]/).map(t => t.trim()).filter(t => t).map(text => ({
                    id: generateId(), en: text, zh: '?', category
                }));
                if (newTags.length === 0) return;

                if (isNewbieMode) {
                    if (slotId.startsWith('nb_')) {
                        setNewbieGeneralSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: [...prev[slotId].tags, ...newTags] } }));
                    } else if (slotId.startsWith('char_')) {
                        setNewbieCharacterSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: [...prev[slotId].tags, ...newTags] } }));
                    }
                } else if (isNaiMultiMode) {
                    if (slotId.startsWith('char_')) {
                        setNaiMultiCharSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: [...prev[slotId].tags, ...newTags] } }));
                    } else if (slotId.startsWith('nb_')) {
                        setNaiMultiBaseSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: [...prev[slotId].tags, ...newTags] } }));
                    }
                } else {
                    setSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: [...prev[slotId].tags, ...newTags] } }));
                }
            };

            const removeTag = (slotId, tagId) => {
                if (isNewbieMode) {
                    if (slotId.startsWith('nb_')) {
                        setNewbieGeneralSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: prev[slotId].tags.filter(t => t.id !== tagId) } }));
                    } else if (slotId.startsWith('char_')) {
                        setNewbieCharacterSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: prev[slotId].tags.filter(t => t.id !== tagId) } }));
                    }
                } else if (isNaiMultiMode) {
                    if (slotId.startsWith('char_')) {
                        setNaiMultiCharSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: prev[slotId].tags.filter(t => t.id !== tagId) } }));
                    } else if (slotId.startsWith('nb_')) {
                        setNaiMultiBaseSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: prev[slotId].tags.filter(t => t.id !== tagId) } }));
                    }
                } else {
                    setSlots(prev => ({ ...prev, [slotId]: { ...prev[slotId], tags: prev[slotId].tags.filter(t => t.id !== tagId) } }));
                }
                if (selectedTagIds.has(tagId)) setSelectedTagIds(prev => { const n = new Set(prev); n.delete(tagId); return n; });
            };

            const updateTagText = (slotId, tagId, newText) => {
                const updateFn = prev => ({
                    ...prev,
                    [slotId]: { ...prev[slotId], tags: prev[slotId].tags.map(t => t.id === tagId ? { ...t, en: newText, zh: '?' } : t) }
                });

                if (isNewbieMode) {
                    slotId.startsWith('nb_') ? setNewbieGeneralSlots(updateFn) : setNewbieCharacterSlots(updateFn);
                } else if (isNaiMultiMode) {
                    slotId.startsWith('char_') ? setNaiMultiCharSlots(updateFn) : setNaiMultiBaseSlots(updateFn);
                } else {
                    setSlots(updateFn);
                }
            };

            const deleteSelectedTags = () => {
                if (selectedTagIds.size === 0) return;
                const filterFn = prev => {
                    const next = { ...prev };
                    Object.keys(next).forEach(key => {
                        if (next[key].tags) next[key].tags = next[key].tags.filter(t => !selectedTagIds.has(t.id));
                    });
                    return next;
                };

                if (isNewbieMode) {
                    setNewbieGeneralSlots(filterFn);
                    setNewbieCharacterSlots(filterFn);
                } else if (isNaiMultiMode) {
                    setNaiMultiBaseSlots(filterFn);
                    setNaiMultiCharSlots(filterFn);
                } else {
                    setSlots(filterFn);
                }
                setSelectedTagIds(new Set());
                showToast("å·²åˆ é™¤é€‰ä¸­æ ‡ç­¾", "success");
            };

            const adjustTagWeight = (slotId, tagId, delta) => {
                if (isNewbieMode) return;

                const updateFn = prev => {
                    const slot = prev[slotId];
                    if (!slot) return prev;
                    const newTags = slot.tags.map(t => {
                        if (t.id !== tagId) return t;
                        let weight = 1.0, text = t.en;

                        if (promptMode === 'nai' || isNaiMultiMode) {
                            const match = t.en.match(/^([0-9.]+)::(.+)::$/);
                            if (match) { weight = parseFloat(match[1]); text = match[2]; }
                        } else {
                            const match = t.en.match(/^\((.+):([0-9.]+)\)$/);
                            if (match) { text = match[1]; weight = parseFloat(match[2]); }
                            else { const m = t.en.match(/^\((.+)\)$/); if (m) text = m[1]; }
                        }

                        let newWeight = Math.round((weight + delta) * 10) / 10;
                        newWeight = Math.max(0.1, Math.min(2.0, newWeight));

                        let newEn;
                        if (newWeight === 1.0) newEn = text;
                        else if (promptMode === 'nai' || isNaiMultiMode) newEn = `${newWeight.toFixed(1)}::${text}::`;
                        else newEn = `(${text}:${newWeight.toFixed(1)})`;

                        return { ...t, en: newEn };
                    });
                    return { ...prev, [slotId]: { ...slot, tags: newTags } };
                };

                if (isNaiMultiMode) {
                    slotId.startsWith('char_') ? setNaiMultiCharSlots(updateFn) : setNaiMultiBaseSlots(updateFn);
                } else {
                    setSlots(updateFn);
                }
            };

            // ================== Tag äº¤äº’ ==================
            const handleTagClick = (tagId, e) => {
                e.stopPropagation();
                if (editingTagId === tagId) return;
                if (e.ctrlKey || e.metaKey) {
                    setSelectedTagIds(prev => { const n = new Set(prev); n.has(tagId) ? n.delete(tagId) : n.add(tagId); return n; });
                } else {
                    if (selectedTagIds.has(tagId) && selectedTagIds.size === 1) setEditingTagId(tagId);
                    else setSelectedTagIds(new Set([tagId]));
                }
            };

            const handleTagDoubleClick = (tagId, e) => {
                e.stopPropagation();
                setEditingTagId(tagId);
                setSelectedTagIds(new Set([tagId]));
            };

            const handleBackgroundClick = () => {
                setSelectedTagIds(new Set());
                setEditingTagId(null);
                setShowModeDropdown(false);
            };

            const finishEditing = (slotId, tagId, text) => {
                setEditingTagId(null);
                if (!text?.trim()) removeTag(slotId, tagId);
            };

            // ================== æ§½ä½æ“ä½œ ==================
            const toggleLock = (id) => {
                if (isNewbieMode && id.startsWith('nb_')) {
                    setNewbieGeneralSlots(prev => ({ ...prev, [id]: { ...prev[id], locked: !prev[id].locked } }));
                } else if (isNaiMultiMode && id.startsWith('nb_')) {
                    setNaiMultiBaseSlots(prev => ({ ...prev, [id]: { ...prev[id], locked: !prev[id].locked } }));
                } else if (!isNewbieMode && !isNaiMultiMode) {
                    setSlots(prev => ({ ...prev, [id]: { ...prev[id], locked: !prev[id].locked } }));
                }
            };

            const toggleInclude = (id) => {
                if (isNewbieMode && id.startsWith('nb_')) {
                    setNewbieGeneralSlots(prev => ({ ...prev, [id]: { ...prev[id], included: !prev[id].included } }));
                } else if (isNaiMultiMode && id.startsWith('nb_')) {
                    setNaiMultiBaseSlots(prev => ({ ...prev, [id]: { ...prev[id], included: !prev[id].included } }));
                } else if (!isNewbieMode && !isNaiMultiMode) {
                    setSlots(prev => ({ ...prev, [id]: { ...prev[id], included: !prev[id].included } }));
                }
            };

            const clearSlotTags = (id) => {
                if (isNewbieMode) {
                    if (id.startsWith('nb_') && !newbieGeneralSlots[id]?.locked) {
                        setNewbieGeneralSlots(prev => ({ ...prev, [id]: { ...prev[id], tags: [] } }));
                    } else if (id.startsWith('char_')) {
                        setNewbieCharacterSlots(prev => ({ ...prev, [id]: { ...prev[id], tags: [] } }));
                    }
                } else if (isNaiMultiMode) {
                    if (id.startsWith('nb_') && !naiMultiBaseSlots[id]?.locked) {
                        setNaiMultiBaseSlots(prev => ({ ...prev, [id]: { ...prev[id], tags: [] } }));
                    } else if (id.startsWith('char_')) {
                        setNaiMultiCharSlots(prev => ({ ...prev, [id]: { ...prev[id], tags: [] } }));
                    }
                } else if (!slots[id]?.locked) {
                    setSlots(prev => ({ ...prev, [id]: { ...prev[id], tags: [] } }));
                }
                showToast("å·²æ¸…ç©ºè¯¥æ ", "success");
            };

            // ================== æ‰¹é‡æ“ä½œ ==================
            const batchLockAll = () => {
                if (isNewbieMode) setNewbieGeneralSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = true); return n; });
                else if (isNaiMultiMode) setNaiMultiBaseSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = true); return n; });
                else setSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = true); return n; });
                showToast("å·²é”å®šæ‰€æœ‰æ¨¡å—", "success");
            };

            const batchUnlockAll = () => {
                if (isNewbieMode) setNewbieGeneralSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = false); return n; });
                else if (isNaiMultiMode) setNaiMultiBaseSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = false); return n; });
                else setSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].locked = false); return n; });
                showToast("å·²è§£é”æ‰€æœ‰æ¨¡å—", "success");
            };

            const batchIncludeAll = () => {
                if (isNewbieMode) setNewbieGeneralSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = true); return n; });
                else if (isNaiMultiMode) setNaiMultiBaseSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = true); return n; });
                else setSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = true); return n; });
                showToast("å·²å‹¾é€‰æ‰€æœ‰æ¨¡å—", "success");
            };

            const batchExcludeAll = () => {
                if (isNewbieMode) setNewbieGeneralSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = false); return n; });
                else if (isNaiMultiMode) setNaiMultiBaseSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = false); return n; });
                else setSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].included = false); return n; });
                showToast("å·²å–æ¶ˆå‹¾é€‰æ‰€æœ‰æ¨¡å—", "success");
            };

            const batchClearWeights = () => {
                if (isNewbieMode) return showToast("NewBie æ¨¡å¼ä¸ä½¿ç”¨æƒé‡", "info");
                const clearFn = prev => {
                    const n = { ...prev };
                    Object.keys(n).forEach(key => {
                        if (n[key].tags) {
                            n[key].tags = n[key].tags.map(tag => {
                                let text = tag.en.replace(/^[0-9.]+::(.+)::$/, '$1').replace(/^\((.+):[0-9.]+\)$/, '$1').replace(/^\((.+)\)$/, '$1');
                                return { ...tag, en: text };
                            });
                        }
                    });
                    return n;
                };
                if (isNaiMultiMode) { setNaiMultiBaseSlots(clearFn); setNaiMultiCharSlots(clearFn); }
                else setSlots(clearFn);
                showToast("å·²é‡ç½®æ‰€æœ‰æƒé‡", "success");
            };

            const batchClearAllContent = () => {
                setConfirmModal({
                    show: true, title: "æ¸…ç©ºæœªé”å®šå†…å®¹", message: "ç¡®å®šæ¸…ç©ºæ‰€æœ‰æœªé”å®šå¡æ§½ï¼Ÿ",
                    onConfirm: () => {
                        if (isNewbieMode) {
                            setNewbieGeneralSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => { if (!n[k].locked) n[k].tags = []; }); return n; });
                            setNewbieCharacterSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].tags = []); return n; });
                        } else if (isNaiMultiMode) {
                            setNaiMultiBaseSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => { if (!n[k].locked) n[k].tags = []; }); return n; });
                            setNaiMultiCharSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => n[k].tags = []); return n; });
                        } else {
                            setSlots(prev => { const n = { ...prev }; Object.keys(n).forEach(k => { if (!n[k].locked) n[k].tags = []; }); return n; });
                        }
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("å·²æ¸…ç©ºæœªé”å®šå†…å®¹", "success");
                    }
                });
            };

            // ================== åŒæ­¥æ»šåŠ¨ï¼ˆ9å®«æ ¼ï¼‰==================
            const handleSyncScroll = (slotId, source) => {
                const refs = scrollRefs.current[slotId];
                if (!refs?.en || !refs?.zh) return;
                const sourceEl = source === 'en' ? refs.en : refs.zh;
                const targetEl = source === 'en' ? refs.zh : refs.en;
                if (isScrolling.current[slotId] && isScrolling.current[slotId] !== source) return;
                isScrolling.current[slotId] = source;
                const maxS = sourceEl.scrollHeight - sourceEl.clientHeight;
                const maxT = targetEl.scrollHeight - targetEl.clientHeight;
                if (maxS > 0 && maxT > 0) targetEl.scrollTop = (sourceEl.scrollTop / maxS) * maxT;
                if (scrollTimeouts.current[slotId]) clearTimeout(scrollTimeouts.current[slotId]);
                scrollTimeouts.current[slotId] = setTimeout(() => { isScrolling.current[slotId] = null; }, 50);
            };

            const handleContainerClick = (slotId, e) => {
                if (e.target.tagName === 'INPUT') return;
                if (slotInputRefs.current[slotId]) slotInputRefs.current[slotId].focus();
                if (!(e.ctrlKey || e.metaKey)) setSelectedTagIds(new Set());
            };

            // ================== 9å®«æ ¼æ‹–æ‹½ ==================
            const handleDragStart = (e, slotId, index) => {
                if (isNewbieMode || isNaiMultiMode) return;
                setDragData({ slotId, index });
                e.dataTransfer.effectAllowed = "move";
            };

            const handleDragOverTag = (e, slotId, index) => {
                if (isNewbieMode || isNaiMultiMode) return;
                e.preventDefault();
                e.stopPropagation();
                if (!dragData || dragData.slotId !== slotId) return;
                const rect = e.currentTarget.getBoundingClientRect();
                const targetIndex = e.clientX > rect.left + rect.width / 2 ? index + 1 : index;
                setDropTarget(prev => (prev?.slotId === slotId && prev?.index === targetIndex) ? prev : { slotId, index: targetIndex });
            };

            const handleDragOverContainer = (e) => { if (!isNewbieMode && !isNaiMultiMode) e.preventDefault(); };

            const handleDrop = (e) => {
                if (isNewbieMode || isNaiMultiMode) return;
                e.preventDefault();
                if (!dragData || !dropTarget || dragData.slotId !== dropTarget.slotId) {
                    setDragData(null); setDropTarget(null); return;
                }
                const { slotId } = dragData;
                const oldIdx = dragData.index, newIdx = dropTarget.index;
                setDragData(null); setDropTarget(null);
                if (oldIdx === newIdx || oldIdx === newIdx - 1) return;

                setSlots(prev => {
                    const slot = prev[slotId];
                    const newTags = [...slot.tags];
                    const [moved] = newTags.splice(oldIdx, 1);
                    newTags.splice(oldIdx < newIdx ? newIdx - 1 : newIdx, 0, moved);
                    return { ...prev, [slotId]: { ...slot, tags: newTags } };
                });
            };


            // ================== OC ç³»ç»Ÿæ“ä½œ ==================
            const updateCurrentCollectionCharacters = (updateFn) => {
                setOcCollections(prev => prev.map(col =>
                    col.id === currentCollectionId ? { ...col, characters: updateFn(col.characters) } : col
                ));
            };

            const createNewCollection = () => {
                const name = newCollectionName.trim() || `æ–‡ä»¶é›† ${ocCollections.length + 1}`;
                const newCol = { id: generateId(), name, characters: [] };
                setOcCollections(prev => [...prev, newCol]);
                setCurrentCollectionId(newCol.id);
                setNewCollectionName('');
                showToast(`å·²åˆ›å»ºã€Œ${name}ã€`, "success");
            };

            const renameCollection = (colId, newName) => {
                if (!newName.trim()) { setEditingCollectionName(null); return; }
                setOcCollections(prev => prev.map(col => col.id === colId ? { ...col, name: newName.trim() } : col));
                setEditingCollectionName(null);
                showToast("å·²é‡å‘½å", "success");
            };

            const deleteCollection = (colId) => {
                if (ocCollections.length <= 1) return showToast("è‡³å°‘ä¿ç•™ä¸€ä¸ªæ–‡ä»¶é›†", "warning");
                setConfirmModal({
                    show: true, title: "åˆ é™¤æ–‡ä»¶é›†", message: "ç¡®å®šåˆ é™¤ï¼Ÿæ‰€æœ‰è§’è‰²æ•°æ®å°†ä¸¢å¤±ã€‚",
                    onConfirm: () => {
                        setOcCollections(prev => prev.filter(col => col.id !== colId));
                        if (currentCollectionId === colId) setCurrentCollectionId(ocCollections.find(c => c.id !== colId)?.id || null);
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("å·²åˆ é™¤æ–‡ä»¶é›†", "success");
                    }
                });
            };

            const createNewOc = () => {
                setEditingOc({ id: generateId(), name: '', core: '', outfits: [], enabled: true });
                setShowOcEditor(true);
            };

            const editOc = (oc) => { setEditingOc({ ...oc }); setShowOcEditor(true); };

            const saveOc = () => {
                if (!editingOc?.name?.trim()) return showToast("è¯·è¾“å…¥è§’è‰²åç§°", "warning");
                updateCurrentCollectionCharacters(chars => {
                    const exists = chars.find(c => c.id === editingOc.id);
                    return exists ? chars.map(c => c.id === editingOc.id ? editingOc : c) : [...chars, editingOc];
                });
                setShowOcEditor(false);
                setEditingOc(null);
                showToast("è§’è‰²å·²ä¿å­˜", "success");
            };

            const deleteOc = (ocId) => {
                setConfirmModal({
                    show: true, title: "åˆ é™¤è§’è‰²", message: "ç¡®å®šåˆ é™¤è¿™ä¸ªè§’è‰²ï¼Ÿ",
                    onConfirm: () => {
                        updateCurrentCollectionCharacters(chars => chars.filter(c => c.id !== ocId));
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("è§’è‰²å·²åˆ é™¤", "success");
                    }
                });
            };

            const toggleOcEnabled = (ocId) => {
                updateCurrentCollectionCharacters(chars => chars.map(c => c.id === ocId ? { ...c, enabled: !c.enabled } : c));
            };

            const addOutfit = () => {
                if (!editingOc) return;
                setEditingOc(prev => ({
                    ...prev,
                    outfits: [...(prev.outfits || []), { id: generateId(), name: `æœè£… ${(prev.outfits?.length || 0) + 1}`, tags: '', enabled: true }]
                }));
            };

            const updateOutfit = (outfitId, field, value) => {
                setEditingOc(prev => ({ ...prev, outfits: prev.outfits.map(o => o.id === outfitId ? { ...o, [field]: value } : o) }));
            };

            const deleteOutfit = (outfitId) => {
                setEditingOc(prev => ({ ...prev, outfits: prev.outfits.filter(o => o.id !== outfitId) }));
            };

            const toggleOutfitInList = (ocId, outfitId) => {
                updateCurrentCollectionCharacters(chars => chars.map(oc =>
                    oc.id === ocId ? { ...oc, outfits: oc.outfits.map(o => o.id === outfitId ? { ...o, enabled: !o.enabled } : o) } : oc
                ));
            };

            // ================== OC æ‹–æ‹½æ’åº ==================
            const handleOcDragStart = (e, index) => {
                if (!ocDragMode) return;
                setOcDragData({ index });
                e.dataTransfer.effectAllowed = "move";
            };

            const handleOcDragOver = (e, index) => {
                if (!ocDragMode || !ocDragData) return;
                e.preventDefault();
                const rect = e.currentTarget.getBoundingClientRect();
                const targetIndex = e.clientY > rect.top + rect.height / 2 ? index + 1 : index;
                if (ocDropTarget !== targetIndex) setOcDropTarget(targetIndex);
            };

            const handleOcDragEnd = () => { setOcDragData(null); setOcDropTarget(null); };

            const handleOcDrop = (e) => {
                e.preventDefault();
                if (!ocDragData || ocDropTarget === null) { handleOcDragEnd(); return; }
                const oldIdx = ocDragData.index;
                let newIdx = ocDropTarget;
                if (oldIdx === newIdx || oldIdx === newIdx - 1) { handleOcDragEnd(); return; }

                updateCurrentCollectionCharacters(chars => {
                    const newChars = [...chars];
                    const [moved] = newChars.splice(oldIdx, 1);
                    newChars.splice(oldIdx < newIdx ? newIdx - 1 : newIdx, 0, moved);
                    return newChars;
                });
                handleOcDragEnd();
                showToast("è§’è‰²é¡ºåºå·²æ›´æ–°", "success");
            };

            const exportCurrentCollection = () => {
                const data = { type: 'oc_collection', version: '2.0', collection: currentCollection };
                const a = document.createElement('a');
                a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
                a.download = `oc_${currentCollection?.name || 'collection'}.json`;
                a.click();
                showToast("å·²å¯¼å‡ºæ–‡ä»¶é›†", "success");
            };

            const handleImportCollection = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.type === 'oc_collection' && data.collection) {
                            const newCol = { ...data.collection, id: generateId() };
                            setOcCollections(prev => [...prev, newCol]);
                            setCurrentCollectionId(newCol.id);
                            showToast(`å·²å¯¼å…¥ã€Œ${newCol.name}ã€`, "success");
                        } else {
                            showToast("æ— æ•ˆçš„æ–‡ä»¶æ ¼å¼", "error");
                        }
                    } catch { showToast("å¯¼å…¥å¤±è´¥", "error"); }
                };
                reader.readAsText(file);
                e.target.value = null;
            };

            // ================== å¤åˆ¶åŠŸèƒ½ ==================
            const copySlotContent = (slotId) => {
                let tags = [];
                if (isNewbieMode) {
                    tags = slotId.startsWith('nb_') ? newbieGeneralSlots[slotId]?.tags : newbieCharacterSlots[slotId]?.tags;
                } else if (isNaiMultiMode) {
                    tags = slotId.startsWith('nb_') ? naiMultiBaseSlots[slotId]?.tags : naiMultiCharSlots[slotId]?.tags;
                } else {
                    tags = slots[slotId]?.tags;
                }
                tags = tags || [];
                if (tags.length === 0) return showToast("è¯¥æ ä¸ºç©º", "info");

                navigator.clipboard.writeText(tags.map(t => t.en).join(", "));
                setSlotCopyFeedback({ id: slotId });
                showToast("å·²å¤åˆ¶è¯¥æ å†…å®¹", "success");
                setTimeout(() => setSlotCopyFeedback(null), 1500);
            };

            const copySelectedTags = () => {
                if (selectedTagIds.size === 0) return;
                const texts = [];
                const collectTags = (slotsObj) => {
                    Object.values(slotsObj).forEach(slot => {
                        slot?.tags?.forEach(t => { if (selectedTagIds.has(t.id)) texts.push(t.en); });
                    });
                };

                if (isNewbieMode) { collectTags(newbieGeneralSlots); collectTags(newbieCharacterSlots); }
                else if (isNaiMultiMode) { collectTags(naiMultiBaseSlots); collectTags(naiMultiCharSlots); }
                else { collectTags(slots); }

                navigator.clipboard.writeText(texts.join(", "));
                showToast(`å·²å¤åˆ¶ ${selectedTagIds.size} ä¸ªæ ‡ç­¾`, "success");
            };

            const copyAllPrompts = () => {
                let text = '';

                if (isNewbieMode) {
                    // NewBie XML æ ¼å¼
                    let xmlParts = [];
                    NEWBIE_CHARACTER_SLOTS.forEach((charConfig, idx) => {
                        const charTags = newbieCharacterSlots[charConfig.id]?.tags || [];
                        if (charTags.length === 0) return;
                        let charXml = `<character_${idx + 1}>\n`;
                        NEWBIE_CATEGORY_CONFIG.character.forEach(cat => {
                            const catTags = charTags.filter(t => t.category === cat.id).map(t => t.en).join(', ');
                            charXml += `  <${cat.xmlTag}>${catTags}</${cat.xmlTag}>\n`;
                        });
                        charXml += `</character_${idx + 1}>`;
                        xmlParts.push(charXml);
                    });

                    let generalXml = '<general_tags>\n';
                    const charCount = NEWBIE_CHARACTER_SLOTS.filter(c => (newbieCharacterSlots[c.id]?.tags || []).length > 0).length;
                    if (charCount > 0) generalXml += `  <count>${charCount === 1 ? '1girl' : charCount + 'girls'}</count>\n`;

                    SLOT_CONFIG_NEWBIE_GENERAL.forEach(config => {
                        const slot = newbieGeneralSlots[config.id];
                        if (!slot?.included || !slot?.tags?.length) return;
                        NEWBIE_CATEGORY_CONFIG[config.id]?.forEach(cat => {
                            const catTags = slot.tags.filter(t => t.category === cat.id).map(t => t.en).join(', ');
                            generalXml += `  <${cat.xmlTag}>${catTags}</${cat.xmlTag}>\n`;
                        });
                    });
                    generalXml += '</general_tags>';
                    xmlParts.push(generalXml);
                    text = xmlParts.join('\n\n');

                } else if (isNaiMultiMode) {
                    // NAI åˆ†è§’è‰²æ ¼å¼ï¼ˆ| åˆ†éš”ï¼‰
                    const parts = [];
                    const baseTags = [];
                    SLOT_CONFIG_NEWBIE_GENERAL.forEach(config => {
                        const slot = naiMultiBaseSlots[config.id];
                        if (slot?.included && slot?.tags?.length > 0) {
                            baseTags.push(...slot.tags.map(t => t.en));
                        }
                    });
                    if (baseTags.length > 0) parts.push(baseTags.join(', '));

                    NEWBIE_CHARACTER_SLOTS.forEach(charConfig => {
                        const charTags = naiMultiCharSlots[charConfig.id]?.tags || [];
                        if (charTags.length > 0) parts.push(charTags.map(t => t.en).join(', '));
                    });
                    text = parts.join(' | ');

                } else {
                    // SD/NAI 9å®«æ ¼æ ¼å¼
                    text = SLOT_CONFIG_STANDARD
                        .filter(c => slots[c.id]?.included)
                        .map(c => slots[c.id]?.tags.map(t => t.en).join(", "))
                        .filter(t => t?.trim())
                        .join(",\n");
                }

                if (!text) return showToast("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹", "warning");
                navigator.clipboard.writeText(text);
                setShowCopyFeedback(true);
                setHasCopied(true);
                showToast("å®Œæ•´å’’è¯­å·²å¤åˆ¶", "success");
                setTimeout(() => setShowCopyFeedback(false), 2000);
            };

            // ================== ç”Ÿæˆæ–‡æœ¬ ==================
            const handleGenerateText = async () => {
                if (!apiKeys[apiProvider]) {
                    setIsSidebarOpen(true); setActiveSidebarTab('settings');
                    return showToast("è¯·é…ç½® API Key", "error");
                }
                setApiError(null);
                setLoadingText("æ­£åœ¨æ„æ€...");
                setIsRolling(true);
                try {
                    const text = await callLLMGenerateRaw(themeInput, generationMode);
                    setGeneratedRawText(text);
                    showToast("æ–‡æœ¬ç”ŸæˆæˆåŠŸ", "success");
                } catch (e) {
                    setApiError(e.message);
                    showToast("ç”Ÿæˆå¤±è´¥: " + e.message, "error");
                } finally {
                    setIsRolling(false);
                }
            };

            // ================== è§£æå¹¶å¡«å…¥ ==================
            const handleParseAndFill = async (textOverride = null) => {
                const textToProcess = textOverride || generatedRawText;
                if (!textToProcess?.trim()) return showToast("è¯·å…ˆç”Ÿæˆæˆ–è¾“å…¥æç¤ºè¯æ–‡æœ¬", "warning");

                setApiError(null);
                setLoadingText("æ­£åœ¨è§£æ...");
                setIsRolling(true);

                try {
                    if (isNewbieMode) {
                        const parsed = parseNewbiePrompt(textToProcess);
                        const total = Object.values(parsed.characters).reduce((a, arr) => a + arr.length, 0) + Object.values(parsed.general).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("æœªæ‰¾åˆ°æœ‰æ•ˆæ ¼å¼", "warning"); setIsRolling(false); return; }

                        let nextGen = JSON.parse(JSON.stringify(newbieGeneralSlots));
                        let leftover = 0;
                        Object.keys(parsed.general).forEach(key => {
                            if (nextGen[key]?.locked) leftover += parsed.general[key].length;
                            else if (parsed.general[key].length > 0) nextGen[key].tags = parsed.general[key];
                        });

                        let nextChar = JSON.parse(JSON.stringify(newbieCharacterSlots));
                        Object.keys(parsed.characters).forEach(key => {
                            if (nextChar[key] && parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key];
                        });

                        actionSource.current = 'ai';
                        setNewbieGeneralSlots(nextGen);
                        setNewbieCharacterSlots(nextChar);
                        showToast(leftover > 0 ? `è§£æå®Œæˆï¼Œ${leftover} ä¸ªè¯å› é”å®šæœªå¡«å…¥` : "è§£æå¹¶å¡«å…¥å®Œæˆï¼", leftover > 0 ? "info" : "success");
                        if (leftover === 0) setIsSidebarOpen(false);

                    } else if (isNaiMultiMode) {
                        const parsed = parseNaiMultiPrompt(textToProcess);
                        const total = Object.values(parsed.base).reduce((a, arr) => a + arr.length, 0) + Object.values(parsed.characters).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("æœªæ‰¾åˆ°æœ‰æ•ˆæ ¼å¼", "warning"); setIsRolling(false); return; }

                        let nextBase = JSON.parse(JSON.stringify(naiMultiBaseSlots));
                        let leftover = 0;
                        Object.keys(parsed.base).forEach(key => {
                            if (nextBase[key]?.locked) leftover += parsed.base[key].length;
                            else if (parsed.base[key].length > 0) nextBase[key].tags = parsed.base[key];
                        });

                        let nextChar = JSON.parse(JSON.stringify(naiMultiCharSlots));
                        Object.keys(parsed.characters).forEach(key => {
                            if (nextChar[key] && parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key];
                        });

                        actionSource.current = 'ai';
                        setNaiMultiBaseSlots(nextBase);
                        setNaiMultiCharSlots(nextChar);
                        showToast(leftover > 0 ? `è§£æå®Œæˆï¼Œ${leftover} ä¸ªè¯å› é”å®šæœªå¡«å…¥` : "è§£æå¹¶å¡«å…¥å®Œæˆï¼", leftover > 0 ? "info" : "success");
                        if (leftover === 0) setIsSidebarOpen(false);

                    } else {
                        const parsed = parseStandardPrompt(textToProcess);
                        const total = Object.values(parsed).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("æœªæ‰¾åˆ°æœ‰æ•ˆæ ¼å¼", "warning"); setIsRolling(false); return; }

                        let nextSlots = JSON.parse(JSON.stringify(slots));
                        let leftover = 0;
                        Object.keys(parsed).forEach(key => {
                            if (nextSlots[key]?.locked) leftover += parsed[key].length;
                            else if (parsed[key].length > 0) nextSlots[key].tags = parsed[key];
                        });

                        actionSource.current = 'ai';
                        setSlots(nextSlots);
                        showToast(leftover > 0 ? `è§£æå®Œæˆï¼Œ${leftover} ä¸ªè¯å› é”å®šæœªå¡«å…¥` : "è§£æå¹¶å¡«å…¥å®Œæˆï¼", leftover > 0 ? "info" : "success");
                        if (leftover === 0) setIsSidebarOpen(false);
                    }
                } catch (e) {
                    setApiError(e.message);
                    showToast("å¤„ç†å¤±è´¥: " + e.message, "error");
                } finally {
                    setIsRolling(false);
                }
            };

            // ================== ä¸€é”® AI æŠ½å¡ ==================
            const handleOneClickRoll = async () => {
                if (!apiKeys[apiProvider]) {
                    setIsSidebarOpen(true); setActiveSidebarTab('settings');
                    return showToast("è¯·é…ç½® API Key", "error");
                }
                setApiError(null);
                setLoadingText("AI åˆ›ä½œä¸­...");
                setIsRolling(true);
                setLastTheme(themeInput);

                try {
                    const text = await callLLMGenerateRaw(themeInput, generationMode);
                    setGeneratedRawText(text);

                    if (isNewbieMode) {
                        const parsed = parseNewbiePrompt(text);
                        const total = Object.values(parsed.characters).reduce((a, arr) => a + arr.length, 0) + Object.values(parsed.general).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("AI è¿”å›æ ¼å¼å¼‚å¸¸", "warning"); setIsRolling(false); return; }

                        let nextGen = JSON.parse(JSON.stringify(newbieGeneralSlots));
                        Object.keys(parsed.general).forEach(key => { if (!nextGen[key]?.locked && parsed.general[key].length > 0) nextGen[key].tags = parsed.general[key]; });
                        let nextChar = JSON.parse(JSON.stringify(newbieCharacterSlots));
                        Object.keys(parsed.characters).forEach(key => { if (parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key]; });

                        actionSource.current = 'ai';
                        setNewbieGeneralSlots(nextGen);
                        setNewbieCharacterSlots(nextChar);
                        setLastAISlots({ general: nextGen, characters: nextChar });

                    } else if (isNaiMultiMode) {
                        const parsed = parseNaiMultiPrompt(text);
                        const total = Object.values(parsed.base).reduce((a, arr) => a + arr.length, 0) + Object.values(parsed.characters).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("AI è¿”å›æ ¼å¼å¼‚å¸¸", "warning"); setIsRolling(false); return; }

                        let nextBase = JSON.parse(JSON.stringify(naiMultiBaseSlots));
                        Object.keys(parsed.base).forEach(key => { if (!nextBase[key]?.locked && parsed.base[key].length > 0) nextBase[key].tags = parsed.base[key]; });
                        let nextChar = JSON.parse(JSON.stringify(naiMultiCharSlots));
                        Object.keys(parsed.characters).forEach(key => { if (parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key]; });

                        actionSource.current = 'ai';
                        setNaiMultiBaseSlots(nextBase);
                        setNaiMultiCharSlots(nextChar);
                        setLastAISlots({ base: nextBase, characters: nextChar });

                    } else {
                        const parsed = parseStandardPrompt(text);
                        const total = Object.values(parsed).reduce((a, arr) => a + arr.length, 0);
                        if (total === 0) { showToast("AI è¿”å›æ ¼å¼å¼‚å¸¸", "warning"); setIsRolling(false); return; }

                        let nextSlots = JSON.parse(JSON.stringify(slots));
                        Object.keys(parsed).forEach(key => { if (!nextSlots[key]?.locked && parsed[key].length > 0) nextSlots[key].tags = parsed[key]; });

                        actionSource.current = 'ai';
                        setSlots(nextSlots);
                        setLastAISlots({ slots: nextSlots });
                    }

                    setHasCopied(false);
                    showToast("ä¸€é”® AI æŠ½å¡å®Œæˆï¼", "success");
                } catch (e) {
                    setApiError(e.message);
                    showToast("æŠ½å¡å¤±è´¥: " + e.message, "error");
                } finally {
                    setIsRolling(false);
                }
            };

            // ================== é‡æ–°ç”Ÿæˆ ==================
            const handleRegenerate = async () => {
                if (!apiKeys[apiProvider]) {
                    setIsSidebarOpen(true); setActiveSidebarTab('settings');
                    return showToast("è¯·é…ç½® API Key", "error");
                }
                if (!lastTheme && !themeInput) return showToast("æ²¡æœ‰ä¸Šä¸€æ¬¡çš„ä¸»é¢˜", "warning");

                setApiError(null);
                setLoadingText("é‡æ–°ç”Ÿæˆä¸­...");
                setIsRolling(true);
                const themeToUse = lastTheme || themeInput;

                if (keepMemory && conversationHistory.length >= 2) {
                    setConversationHistory(prev => prev.slice(0, -2));
                }

                try {
                    const text = await callLLMGenerateRaw(themeToUse, generationMode);
                    setGeneratedRawText(text);

                    if (isNewbieMode) {
                        const parsed = parseNewbiePrompt(text);
                        let nextGen = JSON.parse(JSON.stringify(newbieGeneralSlots));
                        Object.keys(parsed.general).forEach(key => { if (!nextGen[key]?.locked && parsed.general[key].length > 0) nextGen[key].tags = parsed.general[key]; });
                        let nextChar = JSON.parse(JSON.stringify(newbieCharacterSlots));
                        Object.keys(parsed.characters).forEach(key => { if (parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key]; });
                        actionSource.current = 'ai';
                        setNewbieGeneralSlots(nextGen);
                        setNewbieCharacterSlots(nextChar);
                        setLastAISlots({ general: nextGen, characters: nextChar });
                    } else if (isNaiMultiMode) {
                        const parsed = parseNaiMultiPrompt(text);
                        let nextBase = JSON.parse(JSON.stringify(naiMultiBaseSlots));
                        Object.keys(parsed.base).forEach(key => { if (!nextBase[key]?.locked && parsed.base[key].length > 0) nextBase[key].tags = parsed.base[key]; });
                        let nextChar = JSON.parse(JSON.stringify(naiMultiCharSlots));
                        Object.keys(parsed.characters).forEach(key => { if (parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key]; });
                        actionSource.current = 'ai';
                        setNaiMultiBaseSlots(nextBase);
                        setNaiMultiCharSlots(nextChar);
                        setLastAISlots({ base: nextBase, characters: nextChar });
                    } else {
                        const parsed = parseStandardPrompt(text);
                        let nextSlots = JSON.parse(JSON.stringify(slots));
                        Object.keys(parsed).forEach(key => { if (!nextSlots[key]?.locked && parsed[key].length > 0) nextSlots[key].tags = parsed[key]; });
                        actionSource.current = 'ai';
                        setSlots(nextSlots);
                        setLastAISlots({ slots: nextSlots });
                    }

                    setHasCopied(false);
                    showToast("é‡æ–°ç”Ÿæˆå®Œæˆï¼", "success");
                } catch (e) {
                    setApiError(e.message);
                    showToast("é‡æ–°ç”Ÿæˆå¤±è´¥: " + e.message, "error");
                } finally {
                    setIsRolling(false);
                }
            };

            // ================== æ™ºèƒ½ç²˜è´´ ==================
            const handleSmartPaste = async () => {
                if (!apiKeys[apiProvider]) {
                    setIsSidebarOpen(true); setActiveSidebarTab('settings');
                    return showToast("è¯·å…ˆé…ç½® API Key", "error");
                }
                if (!smartPasteContent.trim()) return showToast("è¯·å…ˆç²˜è´´æç¤ºè¯", "warning");

                setIsSmartParsing(true);
                setLoadingText("æ™ºèƒ½è§£æä¸­...");

                try {
                    const parsePrompt = isNewbieMode
                        ? `Parse these tags into NewBie XML format:\n${smartPasteContent}\nOutput: <æç¤ºè¯>...</æç¤ºè¯>`
                        : `Categorize these SD tags:\n${smartPasteContent}\nOutput: <æç¤ºè¯>[category]\\ntag|ä¸­æ–‡...</æç¤ºè¯>`;

                    const result = await callLLM([
                        { role: "system", content: isNewbieMode ? "Categorize into NewBie XML format." : "Categorize SD prompts." },
                        { role: "user", content: parsePrompt }
                    ]);

                    if (isNewbieMode) {
                        const parsed = parseNewbiePrompt(result);
                        let nextGen = JSON.parse(JSON.stringify(newbieGeneralSlots));
                        let leftover = [];
                        Object.keys(parsed.general).forEach(key => {
                            if (nextGen[key]?.locked) leftover.push(...parsed.general[key].map(t => t.en));
                            else if (parsed.general[key].length > 0) nextGen[key].tags = parsed.general[key];
                        });
                        let nextChar = JSON.parse(JSON.stringify(newbieCharacterSlots));
                        Object.keys(parsed.characters).forEach(key => { if (parsed.characters[key].length > 0) nextChar[key].tags = parsed.characters[key]; });

                        setSmartPasteContent(leftover.join(", "));
                        actionSource.current = 'ai';
                        setNewbieGeneralSlots(nextGen);
                        setNewbieCharacterSlots(nextChar);
                        showToast(leftover.length > 0 ? `è§£æå®Œæˆï¼${leftover.length} ä¸ªè¯å› é”å®šæœªå¡«å…¥` : "æ™ºèƒ½è§£æå®Œæˆï¼", leftover.length > 0 ? "info" : "success");
                        if (leftover.length === 0) setIsSidebarOpen(false);
                    } else {
                        const parsed = parseStandardPrompt(result);
                        let nextSlots = JSON.parse(JSON.stringify(slots));
                        let leftover = [];
                        Object.keys(parsed).forEach(key => {
                            if (nextSlots[key]?.locked) leftover.push(...parsed[key].map(t => t.en));
                            else if (parsed[key].length > 0) nextSlots[key].tags = parsed[key];
                        });

                        setSmartPasteContent(leftover.join(", "));
                        actionSource.current = 'ai';
                        setSlots(nextSlots);
                        showToast(leftover.length > 0 ? `è§£æå®Œæˆï¼${leftover.length} ä¸ªè¯å› é”å®šæœªå¡«å…¥` : "æ™ºèƒ½è§£æå®Œæˆï¼", leftover.length > 0 ? "info" : "success");
                        if (leftover.length === 0) setIsSidebarOpen(false);
                    }
                } catch (e) {
                    showToast("è§£æå¤±è´¥: " + e.message, "error");
                } finally {
                    setIsSmartParsing(false);
                }
            };

            // ================== å†å²è®°å½•è·³è½¬ ==================
            const jumpToHistory = (index) => {
                if (index < 0 || index >= history.length) return;
                isHistoryAction.current = true;
                const entry = history[index];

                if (entry.data.mode === 'newbie') {
                    if (entry.data.general) setNewbieGeneralSlots(entry.data.general);
                    if (entry.data.characters) setNewbieCharacterSlots(entry.data.characters);
                } else if (entry.data.mode === 'nai_multi') {
                    if (entry.data.base) setNaiMultiBaseSlots(entry.data.base);
                    if (entry.data.characters) setNaiMultiCharSlots(entry.data.characters);
                } else {
                    if (entry.data.slots) setSlots(entry.data.slots);
                }

                setHistoryIndex(index);
                showToast(`å·²æ¢å¤åˆ° ${entry.timestamp}`, "success");
            };

            // ================== å¯¼å…¥å¯¼å‡º ==================
            const exportAllConfig = () => {
                const exportData = {
                    version: '2.3', type: 'full_backup', exportDate: new Date().toISOString(),
                    data: {}
                };

                if (exportOptions.apiConfig) {
                    exportData.data.apiConfig = {
                        provider: apiProvider, baseUrls: {}, models: {},
                        timeout: apiTimeout, retries: apiRetries,
                        temperature, topP, frequencyPenalty, presencePenalty
                    };
                    Object.keys(API_PROVIDERS).forEach(p => {
                        const url = localStorage.getItem(`sd_api_base_${p}`);
                        const model = localStorage.getItem(`sd_api_model_${p}`);
                        if (url) exportData.data.apiConfig.baseUrls[p] = url;
                        if (model) exportData.data.apiConfig.models[p] = model;
                    });
                }
                if (exportOptions.apiKeys) exportData.data.apiKeys = apiKeys;
                if (exportOptions.ocData) {
                    exportData.data.ocCollections = ocCollections;
                    exportData.data.currentCollectionId = currentCollectionId;
                    exportData.data.ocEnabled = ocEnabled;
                }
                if (exportOptions.promptParts) exportData.data.promptParts = promptParts;
                if (exportOptions.promptPresets) {
                    exportData.data.promptPresets = promptPresets;
                    exportData.data.currentPresetId = currentPresetId;
                }
                if (exportOptions.currentSlots) {
                    exportData.data.slots = slots;
                    exportData.data.newbieGeneralSlots = newbieGeneralSlots;
                    exportData.data.newbieCharacterSlots = newbieCharacterSlots;
                    exportData.data.naiMultiMode = naiMultiMode;
                    exportData.data.naiMultiBaseSlots = naiMultiBaseSlots;
                    exportData.data.naiMultiCharSlots = naiMultiCharSlots;
                }

                exportData.data.userPreferences = userPreferences;
                exportData.data.personalMode = personalMode;
                exportData.data.webSearchMode = webSearchMode;
                exportData.data.webSearchPrompt = webSearchPrompt;
                exportData.data.webSearchResult = webSearchResult;
                exportData.data.webSearchFavorites = webSearchFavorites;
                exportData.data.lastTheme = lastTheme;
                exportData.data.conversationHistory = conversationHistory;
                exportData.data.themeInput = themeInput;
                exportData.data.generationMode = generationMode;
                exportData.data.keepMemory = keepMemory;
                exportData.data.promptMode = promptMode;

                const a = document.createElement('a');
                a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
                a.download = `sd_gacha_backup_${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                showToast("å…¨é‡å¤‡ä»½å·²å¯¼å‡º", "success");
            };

            const handleImportConfig = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.type !== 'full_backup') return showToast("æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼", "error");

                        setConfirmModal({
                            show: true, title: "ç¡®è®¤å¯¼å…¥", message: "å¯¼å…¥å°†è¦†ç›–ç°æœ‰é…ç½®ï¼Œç¡®å®šç»§ç»­ï¼Ÿ",
                            onConfirm: () => {
                                if (data.data.apiConfig) {
                                    setApiProvider(data.data.apiConfig.provider);
                                    localStorage.setItem('sd_api_provider', data.data.apiConfig.provider);
                                    Object.entries(data.data.apiConfig.baseUrls || {}).forEach(([p, url]) => localStorage.setItem(`sd_api_base_${p}`, url));
                                    Object.entries(data.data.apiConfig.models || {}).forEach(([p, model]) => localStorage.setItem(`sd_api_model_${p}`, model));
                                    setCurrentBaseUrl(data.data.apiConfig.baseUrls?.[data.data.apiConfig.provider] || API_PROVIDERS[data.data.apiConfig.provider]?.defaultBaseUrl || '');
                                    setCurrentModel(data.data.apiConfig.models?.[data.data.apiConfig.provider] || API_PROVIDERS[data.data.apiConfig.provider]?.defaultModel || '');
                                    if (data.data.apiConfig.timeout) setApiTimeout(data.data.apiConfig.timeout);
                                    if (data.data.apiConfig.retries) setApiRetries(data.data.apiConfig.retries);
                                    if (data.data.apiConfig.temperature) setTemperature(data.data.apiConfig.temperature);
                                    if (data.data.apiConfig.topP) setTopP(data.data.apiConfig.topP);
                                    if (data.data.apiConfig.frequencyPenalty) setFrequencyPenalty(data.data.apiConfig.frequencyPenalty);
                                    if (data.data.apiConfig.presencePenalty) setPresencePenalty(data.data.apiConfig.presencePenalty);
                                }
                                if (data.data.apiKeys) { setApiKeys(data.data.apiKeys); localStorage.setItem('sd_api_keys', JSON.stringify(data.data.apiKeys)); }
                                if (data.data.ocCollections) {
                                    setOcCollections(data.data.ocCollections);
                                    setCurrentCollectionId(data.data.currentCollectionId || data.data.ocCollections[0]?.id);
                                }
                                if (data.data.ocEnabled !== undefined) setOcEnabled(data.data.ocEnabled);
                                if (data.data.promptParts) setPromptParts(data.data.promptParts);
                                if (data.data.promptPresets) setPromptPresets(data.data.promptPresets);
                                if (data.data.currentPresetId) setCurrentPresetId(data.data.currentPresetId);
                                if (data.data.slots) { actionSource.current = 'import'; setSlots(data.data.slots); }
                                if (data.data.newbieGeneralSlots) setNewbieGeneralSlots(data.data.newbieGeneralSlots);
                                if (data.data.newbieCharacterSlots) setNewbieCharacterSlots(data.data.newbieCharacterSlots);
                                if (data.data.naiMultiMode !== undefined) setNaiMultiMode(data.data.naiMultiMode);
                                if (data.data.naiMultiBaseSlots) setNaiMultiBaseSlots(data.data.naiMultiBaseSlots);
                                if (data.data.naiMultiCharSlots) setNaiMultiCharSlots(data.data.naiMultiCharSlots);
                                if (data.data.userPreferences !== undefined) setUserPreferences(data.data.userPreferences);
                                if (data.data.personalMode) setPersonalMode(data.data.personalMode);
                                if (data.data.webSearchMode) setWebSearchMode(data.data.webSearchMode);
                                if (data.data.webSearchPrompt) setWebSearchPrompt(data.data.webSearchPrompt);
                                if (data.data.webSearchResult !== undefined) setWebSearchResult(data.data.webSearchResult);
                                if (data.data.webSearchFavorites) setWebSearchFavorites(data.data.webSearchFavorites);
                                if (data.data.lastTheme !== undefined) setLastTheme(data.data.lastTheme);
                                if (data.data.conversationHistory) setConversationHistory(data.data.conversationHistory);
                                if (data.data.themeInput !== undefined) setThemeInput(data.data.themeInput);
                                if (data.data.generationMode) setGenerationMode(data.data.generationMode);
                                if (data.data.keepMemory !== undefined) setKeepMemory(data.data.keepMemory);
                                if (data.data.promptMode) setPromptMode(data.data.promptMode);

                                setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                                showToast("å¤‡ä»½å·²æˆåŠŸå¯¼å…¥", "success");
                            }
                        });
                    } catch { showToast("å¯¼å…¥å¤±è´¥ï¼šæ— æ³•è§£ææ–‡ä»¶", "error"); }
                };
                reader.readAsText(file);
                e.target.value = null;
            };

            // ================== é‡ç½®æ‰€æœ‰çŠ¶æ€ ==================
            const resetAllStates = () => {
                setPromptParts({ ...DEFAULT_PROMPT_PARTS });
                setPromptPresets([]);
                setCurrentPresetId(null);
                setOcCollections([{ ...DEFAULT_OC_COLLECTION, id: generateId() }]);
                setCurrentCollectionId(null);
                setOcEnabled(false);
                setApiKeys({});
                setApiConnected(false);
                setApiProvider('deepseek');
                setCurrentBaseUrl(API_PROVIDERS.deepseek.defaultBaseUrl);
                setCurrentModel(API_PROVIDERS.deepseek.defaultModel);
                setApiTimeout(60000);
                setApiRetries(3);
                setTemperature(1);
                setTopP(0.9);
                setFrequencyPenalty(0);
                setPresencePenalty(0);
                setUserPreferences('');
                setPersonalMode('off');
                setWebSearchMode('off');
                setWebSearchPrompt(DEFAULT_WEB_SEARCH_PROMPT);
                setWebSearchResult('');
                setWebSearchFavorites([]);
                setLastTheme('');
                setConversationHistory([]);
                setThemeInput('');
                setGenerationMode('detailed');
                setKeepMemory(false);
                setPromptMode('sd');
                setNaiMultiMode(false);

                // é‡ç½®æ§½ä½
                const initSlots = {};
                SLOT_CONFIG_STANDARD.forEach(c => {
                    initSlots[c.id] = { tags: c.id === 'quality' ? [...INITIAL_QUALITY_TAGS] : [], locked: c.id === 'quality', included: true };
                });
                setSlots(initSlots);

                const initNewbieGen = {};
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(c => {
                    initNewbieGen[c.id] = {
                        tags: c.id === 'nb_quality' ? [
                            { id: generateId(), en: 'masterpiece', zh: 'æ°ä½œ', category: 'quality' },
                            { id: generateId(), en: 'best_quality', zh: 'æœ€ä½³è´¨é‡', category: 'quality' },
                            { id: generateId(), en: 'highres', zh: 'é«˜åˆ†è¾¨ç‡', category: 'resolution' },
                            { id: generateId(), en: 'anime_style', zh: 'åŠ¨æ¼«é£æ ¼', category: 'style' },
                        ] : [],
                        locked: c.id === 'nb_quality', included: true
                    };
                });
                setNewbieGeneralSlots(initNewbieGen);

                const initNewbieChar = {};
                NEWBIE_CHARACTER_SLOTS.forEach(c => { initNewbieChar[c.id] = { tags: [] }; });
                setNewbieCharacterSlots(initNewbieChar);

                const initNaiBase = {};
                SLOT_CONFIG_NEWBIE_GENERAL.forEach(c => {
                    initNaiBase[c.id] = {
                        tags: c.id === 'nb_quality' ? [
                            { id: generateId(), en: 'masterpiece', zh: 'æ°ä½œ', category: 'quality' },
                            { id: generateId(), en: 'best quality', zh: 'æœ€ä½³è´¨é‡', category: 'quality' },
                        ] : [],
                        locked: c.id === 'nb_quality', included: true
                    };
                });
                setNaiMultiBaseSlots(initNaiBase);

                const initNaiChar = {};
                NEWBIE_CHARACTER_SLOTS.forEach(c => { initNaiChar[c.id] = { tags: [] }; });
                setNaiMultiCharSlots(initNaiChar);

                setHistory([]);
                setHistoryIndex(-1);
            };

            const clearAllCache = () => {
                setConfirmModal({
                    show: true, title: "æ¸…é™¤æ‰€æœ‰ç¼“å­˜", message: "å°†å…ˆå¯¼å‡ºå¤‡ä»½ï¼Œç„¶åæ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ã€‚ç¡®å®šï¼Ÿ",
                    onConfirm: () => {
                        exportAllConfig();
                        const keysToRemove = [];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('sd_')) keysToRemove.push(key);
                        }
                        keysToRemove.forEach(key => localStorage.removeItem(key));
                        resetAllStates();
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("å·²å¯¼å‡ºå¤‡ä»½å¹¶æ¸…é™¤æ‰€æœ‰ç¼“å­˜", "success");
                    }
                });
            };

            const resetAllSettings = () => {
                setConfirmModal({
                    show: true, title: "é‡ç½®æ‰€æœ‰è®¾ç½®", message: "ç¡®å®šé‡ç½®æ‰€æœ‰è®¾ç½®ä¸ºé»˜è®¤å€¼ï¼Ÿï¼ˆä¸ä¼šå¯¼å‡ºå¤‡ä»½ï¼‰",
                    onConfirm: () => {
                        localStorage.clear();
                        resetAllStates();
                        setConfirmModal({ show: false, title: "", message: "", onConfirm: null });
                        showToast("å·²é‡ç½®æ‰€æœ‰è®¾ç½®", "success");
                    }
                });
            };

            const handleBottomButtonClick = () => {
                if (!apiKeys[apiProvider]) {
                    setIsSidebarOpen(true);
                    setActiveSidebarTab('settings');
                    return showToast("è¯·é…ç½® API Key", "warning");
                }
                handleOneClickRoll();
            };


            // ================== æ¸²æŸ“ ==================
            return (
                <div className="min-h-screen pb-24 relative overflow-x-hidden" onClick={handleBackgroundClick}>
                    {/* Toast é€šçŸ¥ */}
                    <div className="fixed top-4 right-4 z-[100] flex flex-col gap-2 pointer-events-none">
                        {toasts.map(toast => {
                            const config = { success: { bg: "bg-emerald-600/90 border-emerald-500/50", Icon: CheckCircle2 }, error: { bg: "bg-red-600/90 border-red-500/50", Icon: XCircle }, warning: { bg: "bg-amber-500/90 border-amber-400/50", Icon: AlertTriangle } };
                            const { bg, Icon } = config[toast.type] || { bg: "bg-slate-700/90 border-slate-600/50", Icon: Info };
                            return (
                                <div key={toast.id} className={`pointer-events-auto flex items-center gap-2 px-3 py-2 rounded-lg border shadow-xl backdrop-blur-md max-w-xs text-white text-sm ${bg}`}>
                                    <Icon className="w-4 h-4" /><span className="font-medium">{toast.message}</span>
                                    <button onClick={() => setToasts(prev => prev.filter(t => t.id !== toast.id))} className="ml-auto opacity-70 hover:opacity-100"><X className="w-3.5 h-3.5" /></button>
                                </div>
                            );
                        })}
                    </div>

                    {/* ç¡®è®¤å¼¹çª— */}
                    {confirmModal.show && (
                        <div className="fixed inset-0 z-[120] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4">
                            <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl p-5 max-w-sm w-full" onClick={e => e.stopPropagation()}>
                                <h3 className="text-lg font-bold text-white mb-2 flex items-center gap-2"><AlertTriangle className="w-5 h-5 text-yellow-500" />{confirmModal.title}</h3>
                                <p className="text-slate-400 mb-5 text-sm">{confirmModal.message}</p>
                                <div className="flex justify-end gap-3">
                                    <button onClick={() => setConfirmModal({ ...confirmModal, show: false })} className="px-4 py-2 rounded-lg text-slate-300 hover:bg-slate-800 text-sm">å–æ¶ˆ</button>
                                    <button onClick={confirmModal.onConfirm} className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-500 text-white font-medium text-sm">ç¡®è®¤</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* OC ç¼–è¾‘å™¨å¼¹çª— */}
                    {showOcEditor && editingOc && (
                        <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4">
                            <div className="bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl w-full max-w-2xl max-h-[85vh] flex flex-col overflow-hidden" onClick={e => e.stopPropagation()}>
                                <div className="flex items-center justify-between px-5 py-3 border-b border-slate-800">
                                    <h3 className="text-lg font-bold text-white flex items-center gap-2"><User className="w-5 h-5 text-pink-400" />{currentCharacters.find(oc => oc.id === editingOc.id) ? 'ç¼–è¾‘è§’è‰²' : 'æ–°å»ºè§’è‰²'}</h3>
                                    <button onClick={() => { setShowOcEditor(false); setEditingOc(null); }} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white"><X className="w-5 h-5" /></button>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-5 space-y-5">
                                    <div>
                                        <label className="block text-sm font-medium text-slate-300 mb-2">åç§°</label>
                                        <input type="text" value={editingOc.name} onChange={(e) => setEditingOc(prev => ({ ...prev, name: e.target.value }))} className="w-full bg-slate-950 border border-slate-700 rounded-lg px-4 py-2.5 text-white focus:border-pink-500" placeholder="è§’è‰²åç§°" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-300 mb-2 flex items-center gap-2"><User className="w-4 h-4 text-blue-400" /> OC æœ¬ä½“</label>
                                        <textarea value={editingOc.core} onChange={(e) => setEditingOc(prev => ({ ...prev, core: e.target.value }))} className="w-full h-28 bg-slate-950 border border-slate-700 rounded-lg px-4 py-3 text-slate-200 text-sm font-mono focus:border-blue-500 resize-none" placeholder="1girl, character_name, long white hair..." />
                                    </div>
                                    <div>
                                        <div className="flex items-center justify-between mb-3">
                                            <label className="text-sm font-medium text-slate-300 flex items-center gap-2"><Shirt className="w-4 h-4 text-purple-400" /> æœè£…æ–¹æ¡ˆ</label>
                                            <button onClick={addOutfit} className="flex items-center gap-1 px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-xs"><Plus className="w-3.5 h-3.5" /> æ·»åŠ </button>
                                        </div>
                                        <div className="space-y-3">
                                            {editingOc.outfits?.length === 0 && <div className="text-center py-6 text-slate-600 border-2 border-dashed border-slate-800 rounded-xl"><Shirt className="w-8 h-8 mx-auto mb-2 opacity-50" /><p className="text-sm">æš‚æ— æœè£…</p></div>}
                                            {editingOc.outfits?.map((outfit) => (
                                                <div key={outfit.id} className="bg-slate-800/50 border border-slate-700 rounded-xl p-3">
                                                    <div className="flex items-center gap-3 mb-2">
                                                        <button onClick={() => updateOutfit(outfit.id, 'enabled', !outfit.enabled)} className={`p-0.5 rounded ${outfit.enabled ? 'text-emerald-400' : 'text-slate-600'}`}>{outfit.enabled ? <CheckSquare className="w-5 h-5" /> : <Square className="w-5 h-5" />}</button>
                                                        <input type="text" value={outfit.name} onChange={(e) => updateOutfit(outfit.id, 'name', e.target.value)} className="flex-1 bg-slate-900 border border-slate-600 rounded-lg px-3 py-1.5 text-white text-sm focus:border-purple-500" />
                                                        <button onClick={() => deleteOutfit(outfit.id)} className="p-1.5 text-slate-500 hover:text-red-400"><Trash2 className="w-4 h-4" /></button>
                                                    </div>
                                                    <textarea value={outfit.tags} onChange={(e) => updateOutfit(outfit.id, 'tags', e.target.value)} className="w-full h-16 bg-slate-900 border border-slate-700 rounded-lg px-3 py-2 text-slate-300 text-xs font-mono resize-none" placeholder="school uniform, white stockings..." />
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                                <div className="flex items-center justify-end gap-3 px-5 py-3 border-t border-slate-800">
                                    <button onClick={() => { setShowOcEditor(false); setEditingOc(null); }} className="px-4 py-2 text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg text-sm">å–æ¶ˆ</button>
                                    <button onClick={saveOc} className="px-5 py-2 bg-pink-600 hover:bg-pink-500 text-white font-medium rounded-lg text-sm flex items-center gap-2"><Save className="w-4 h-4" /> ä¿å­˜</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* å–œå¥½å¼¹çª— */}
                    {showPreferencesModal && (
                        <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4">
                            <div className="bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl w-full max-w-lg flex flex-col overflow-hidden" onClick={e => e.stopPropagation()}>
                                <div className="flex items-center justify-between px-5 py-3 border-b border-slate-800">
                                    <h3 className="text-lg font-bold text-white flex items-center gap-2"><Sparkles className="w-5 h-5 text-emerald-400" />ç”¨æˆ·å–œå¥½</h3>
                                    <button onClick={() => setShowPreferencesModal(false)} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400"><X className="w-5 h-5" /></button>
                                </div>
                                <div className="p-5">
                                    <textarea value={userPreferences} onChange={(e) => setUserPreferences(e.target.value)} className="w-full h-48 bg-slate-950 border border-slate-700 rounded-xl px-4 py-3 text-slate-200 text-sm resize-none focus:border-emerald-500 custom-scrollbar" placeholder="AI æ€»ç»“çš„å–œå¥½..." />
                                </div>
                                <div className="flex items-center justify-between px-5 py-3 border-t border-slate-800">
                                    <button onClick={() => { setUserPreferences(''); showToast("å·²æ¸…ç©º", "success"); }} className="px-4 py-2 text-red-400 hover:bg-red-500/10 rounded-lg text-sm flex items-center gap-1"><Trash2 className="w-4 h-4" /> æ¸…ç©º</button>
                                    <button onClick={() => { setShowPreferencesModal(false); showToast("å·²ä¿å­˜", "success"); }} className="px-5 py-2 bg-emerald-600 hover:bg-emerald-500 text-white font-medium rounded-lg text-sm"><Save className="w-4 h-4" /> ä¿å­˜</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* è”ç½‘æ£€ç´¢å¼¹çª— */}
                    {showWebSearchModal && (
                        <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4">
                            <div className="bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl w-full max-w-3xl max-h-[90vh] flex flex-col overflow-hidden" onClick={e => e.stopPropagation()}>
                                <div className="flex items-center justify-between px-5 py-3 border-b border-slate-800">
                                    <h3 className="text-lg font-bold text-white flex items-center gap-2"><Globe className="w-5 h-5 text-blue-400" />è”ç½‘æ£€ç´¢</h3>
                                    <button onClick={() => setShowWebSearchModal(false)} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400"><X className="w-5 h-5" /></button>
                                </div>
                                <div className="flex border-b border-slate-800 bg-slate-950/50">
                                    {[{ id: 'result', label: 'ç»“æœ', icon: Search }, { id: 'favorites', label: 'æ”¶è—', icon: Heart }, { id: 'help', label: 'è¯´æ˜', icon: Info }].map(tab => (
                                        <button key={tab.id} onClick={() => setWebSearchTab(tab.id)} className={`flex-1 py-2.5 flex items-center justify-center gap-1.5 text-xs font-medium ${webSearchTab === tab.id ? 'text-blue-400 border-b-2 border-blue-400' : 'text-slate-500 hover:text-slate-300'}`}>
                                            <tab.icon className="w-3.5 h-3.5" />{tab.label}
                                            {tab.id === 'favorites' && webSearchFavorites.length > 0 && <span className="ml-1 px-1.5 py-0.5 bg-blue-500/20 text-blue-400 rounded-full text-[10px]">{webSearchFavorites.length}</span>}
                                        </button>
                                    ))}
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-5">
                                    {webSearchTab === 'result' && (
                                        <div className="space-y-4">
                                            <div>
                                                <div className="flex items-center justify-between mb-2">
                                                    <label className="text-sm font-medium text-slate-300">æ£€ç´¢æç¤ºè¯</label>
                                                    <button onClick={resetWebSearchPrompt} className="text-[10px] text-slate-500 hover:text-amber-400 flex items-center gap-1"><RotateCcw className="w-3 h-3" /> é‡ç½®</button>
                                                </div>
                                                <textarea value={webSearchPrompt} onChange={(e) => setWebSearchPrompt(e.target.value)} className="w-full h-24 bg-slate-950 border border-slate-700 rounded-lg px-3 py-2 text-slate-300 text-xs font-mono resize-none" />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-slate-300 mb-2">è§’è‰²åç§°</label>
                                                <div className="flex gap-2">
                                                    <input type="text" value={webSearchQuery} onChange={(e) => setWebSearchQuery(e.target.value)} className="flex-1 bg-slate-950 border border-slate-700 rounded-lg px-3 py-2 text-white text-sm" placeholder="åˆ»æ™´ã€æ‹‰è²..." />
                                                    <button onClick={handleWebSearch} disabled={isWebSearching || !webSearchQuery.trim()} className="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white rounded-lg text-sm flex items-center gap-2">
                                                        {isWebSearching ? <Loader2 className="w-4 h-4 animate-spin" /> : <Search className="w-4 h-4" />}{isWebSearching ? 'æ£€ç´¢ä¸­' : 'æ£€ç´¢'}
                                                    </button>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex items-center justify-between mb-2">
                                                    <label className="text-sm font-medium text-slate-300">æ£€ç´¢ç»“æœ</label>
                                                    {webSearchResult && (
                                                        <div className="flex gap-2">
                                                            <button onClick={saveWebSearchToFavorites} className="text-[10px] text-slate-500 hover:text-pink-400 px-2 py-1 bg-slate-800 rounded"><Heart className="w-3 h-3 inline mr-1" />æ”¶è—</button>
                                                            <button onClick={() => setWebSearchResult('')} className="text-[10px] text-slate-500 hover:text-red-400 px-2 py-1 bg-slate-800 rounded"><Trash2 className="w-3 h-3 inline mr-1" />æ¸…ç©º</button>
                                                        </div>
                                                    )}
                                                </div>
                                                <textarea value={webSearchResult} onChange={(e) => setWebSearchResult(e.target.value)} className="w-full h-48 bg-slate-950 border border-slate-700 rounded-lg px-3 py-2 text-slate-300 text-xs font-mono resize-none" placeholder="æ£€ç´¢ç»“æœ..." />
                                            </div>
                                        </div>
                                    )}
                                    {webSearchTab === 'favorites' && (
                                        <div className="space-y-3">
                                            {webSearchFavorites.length === 0 ? <div className="flex flex-col items-center py-10 text-slate-600"><Heart className="w-10 h-10 mb-2 opacity-30" /><p className="text-sm">æš‚æ— æ”¶è—</p></div> : webSearchFavorites.map(fav => (
                                                <div key={fav.id} className="bg-slate-800/50 border border-slate-700 rounded-xl p-3">
                                                    <div className="flex items-center justify-between mb-2">
                                                        <span className="font-medium text-white text-sm">{fav.name}</span>
                                                        <div className="flex gap-1">
                                                            <button onClick={() => loadFavoriteToResult(fav)} className="p-1.5 text-slate-500 hover:text-blue-400"><Upload className="w-3.5 h-3.5" /></button>
                                                            <button onClick={() => deleteWebSearchFavorite(fav.id)} className="p-1.5 text-slate-500 hover:text-red-400"><Trash2 className="w-3.5 h-3.5" /></button>
                                                        </div>
                                                    </div>
                                                    <div className="text-[10px] text-slate-500 bg-slate-900/50 rounded-lg p-2 max-h-20 overflow-y-auto font-mono">{fav.content.slice(0, 200)}...</div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {webSearchTab === 'help' && (
                                        <div className="space-y-4 text-sm">
                                            <div className="bg-blue-500/10 border border-blue-500/30 rounded-xl p-4">
                                                <h4 className="font-bold text-blue-300 mb-2">åŠŸèƒ½è¯´æ˜</h4>
                                                <p className="text-slate-300">ç”¨äºæœç´¢è§’è‰²çš„è¯¦ç»†è§†è§‰ç‰¹å¾ã€‚è¯·ç¡®ä¿ API æ¨¡å‹æ”¯æŒè”ç½‘ã€‚</p>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                <div className="flex items-center justify-between px-5 py-3 border-t border-slate-800">
                                    <button onClick={toggleWebSearchMode} className={`px-3 py-1.5 rounded-lg text-xs font-medium ${webSearchMode === 'off' ? 'bg-slate-700 text-slate-300' : webSearchMode === 'on' ? 'bg-blue-600 text-white' : 'bg-amber-600 text-white'}`}>
                                        {webSearchMode === 'off' ? 'å…³é—­' : webSearchMode === 'on' ? 'å¼€å¯' : 'ä»…å‘é€'}
                                    </button>
                                    <button onClick={() => setShowWebSearchModal(false)} className="px-5 py-2 bg-slate-700 hover:bg-slate-600 text-white font-medium rounded-lg text-sm">å®Œæˆ</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* ç§»åŠ¨ç«¯é®ç½© */}
                    {ocPanelOpen && isMobile && <div className="fixed inset-0 bg-black/60 z-30" onClick={() => setOcPanelOpen(false)} />}

                    {/* å·¦ä¾§ OC é¢æ¿ */}
                    <div className={`fixed top-0 left-0 h-full z-40 transition-all duration-300 ${ocPanelOpen ? 'w-72 translate-x-0' : isMobile ? 'w-72 -translate-x-full' : 'w-12 translate-x-0'}`} onClick={e => e.stopPropagation()}>
                        {!ocPanelOpen && !isMobile && (
                            <div className="h-full bg-slate-900/95 border-r border-slate-800 flex flex-col items-center py-4">
                                <button onClick={() => setOcPanelOpen(true)} className={`p-2.5 rounded-xl ${ocEnabled ? 'bg-pink-500/20 text-pink-400 border border-pink-500/30' : 'bg-slate-800 text-slate-500 hover:text-slate-300'}`}><User className="w-5 h-5" /></button>
                                {ocEnabled && currentCharacters.filter(oc => oc.enabled).length > 0 && <div className="mt-2 w-5 h-5 bg-pink-500 text-white text-[10px] font-bold rounded-full flex items-center justify-center">{currentCharacters.filter(oc => oc.enabled).length}</div>}
                            </div>
                        )}
                        {ocPanelOpen && (
                            <div className="h-full bg-slate-900 border-r border-slate-800 flex flex-col">
                                <div className="flex items-center justify-between px-3 py-2.5 border-b border-slate-800">
                                    <div className="flex items-center gap-2"><User className="w-4 h-4 text-pink-400" /><span className="font-bold text-white text-sm">åŸåˆ›è§’è‰²</span></div>
                                    <div className="flex items-center gap-1.5">
                                        <button onClick={() => setOcDragMode(!ocDragMode)} className={`p-1.5 rounded-lg ${ocDragMode ? 'bg-amber-500/20 text-amber-400 border border-amber-500/30' : 'text-slate-500 hover:text-slate-300'}`}><GripVertical className="w-3.5 h-3.5" /></button>
                                        <button onClick={() => setOcEnabled(!ocEnabled)} className={`relative w-10 h-5 rounded-full ${ocEnabled ? 'bg-pink-500' : 'bg-slate-700'}`}><div className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-all ${ocEnabled ? 'left-5' : 'left-0.5'}`} /></button>
                                        <button onClick={() => setOcPanelOpen(false)} className="p-1 hover:bg-slate-800 rounded-lg text-slate-400"><ChevronLeft className="w-4 h-4" /></button>
                                    </div>
                                </div>
                                <div className="px-2 py-2 border-b border-slate-800 bg-slate-950/50">
                                    <div className="relative">
                                        <button onClick={() => setShowCollectionDropdown(!showCollectionDropdown)} className="w-full flex items-center justify-between gap-1.5 px-2.5 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-lg text-xs text-white">
                                            <div className="flex items-center gap-1.5 truncate"><Folder className="w-3.5 h-3.5 text-amber-400" /><span className="truncate">{currentCollection?.name || 'é€‰æ‹©æ–‡ä»¶é›†'}</span></div>
                                            <ChevronDown className={`w-3.5 h-3.5 text-slate-400 transition-transform ${showCollectionDropdown ? 'rotate-180' : ''}`} />
                                        </button>
                                        {showCollectionDropdown && (
                                            <div className="absolute top-full left-0 right-0 mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-50 max-h-48 overflow-y-auto custom-scrollbar">
                                                {ocCollections.map(col => (
                                                    <div key={col.id} className={`flex items-center gap-2 px-2.5 py-1.5 hover:bg-slate-700 cursor-pointer text-xs ${col.id === currentCollectionId ? 'bg-slate-700' : ''}`}>
                                                        {editingCollectionName === col.id ? (
                                                            <input type="text" defaultValue={col.name} autoFocus className="flex-1 bg-slate-900 border border-slate-600 rounded px-2 py-1 text-xs text-white" onBlur={(e) => renameCollection(col.id, e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') renameCollection(col.id, e.target.value); if (e.key === 'Escape') setEditingCollectionName(null); }} onClick={e => e.stopPropagation()} />
                                                        ) : (
                                                            <>
                                                                <div className="flex-1 flex items-center gap-1.5" onClick={() => { setCurrentCollectionId(col.id); setShowCollectionDropdown(false); }}>
                                                                    <Folder className={`w-3.5 h-3.5 ${col.id === currentCollectionId ? 'text-amber-400' : 'text-slate-500'}`} />
                                                                    <span className="text-white truncate">{col.name}</span>
                                                                    <span className="text-slate-500">({col.characters.length})</span>
                                                                </div>
                                                                <button onClick={(e) => { e.stopPropagation(); setEditingCollectionName(col.id); }} className="p-1 text-slate-500 hover:text-blue-400"><Edit3 className="w-3 h-3" /></button>
                                                                {ocCollections.length > 1 && <button onClick={(e) => { e.stopPropagation(); deleteCollection(col.id); setShowCollectionDropdown(false); }} className="p-1 text-slate-500 hover:text-red-400"><Trash2 className="w-3 h-3" /></button>}
                                                            </>
                                                        )}
                                                    </div>
                                                ))}
                                                <div className="border-t border-slate-700 p-2">
                                                    <div className="flex items-center gap-1.5">
                                                        <input type="text" value={newCollectionName} onChange={e => setNewCollectionName(e.target.value)} placeholder="æ–°æ–‡ä»¶é›†..." className="flex-1 bg-slate-900 border border-slate-600 rounded-lg px-2 py-1 text-xs text-white" onKeyDown={e => { if (e.key === 'Enter' && newCollectionName.trim()) { createNewCollection(); setShowCollectionDropdown(false); } }} />
                                                        <button onClick={() => { if (newCollectionName.trim()) { createNewCollection(); setShowCollectionDropdown(false); } }} className="p-1.5 bg-pink-600 hover:bg-pink-500 text-white rounded-lg"><Plus className="w-3.5 h-3.5" /></button>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex items-center gap-1.5 mt-1.5">
                                        <button onClick={() => ocFileInputRef.current?.click()} className="flex-1 flex items-center justify-center gap-1 py-1 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-[10px]"><Download className="w-3 h-3" /> å¯¼å…¥</button>
                                        <button onClick={exportCurrentCollection} className="flex-1 flex items-center justify-center gap-1 py-1 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-[10px]"><Upload className="w-3 h-3" /> å¯¼å‡º</button>
                                        <input type="file" ref={ocFileInputRef} onChange={handleImportCollection} accept=".json" className="hidden" />
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-2 space-y-2" onDragOver={e => { if (ocDragMode) e.preventDefault(); }} onDrop={handleOcDrop}>
                                    {ocDragMode && <div className="flex items-center gap-2 px-2 py-1.5 bg-amber-500/10 border border-amber-500/30 rounded-lg mb-2"><GripVertical className="w-3.5 h-3.5 text-amber-400" /><span className="text-[10px] text-amber-300">æ‹–åŠ¨æ¨¡å¼å¼€å¯</span></div>}
                                    {currentCharacters.length === 0 ? <div className="flex flex-col items-center py-10 text-slate-600"><User className="w-10 h-10 mb-2 opacity-30" /><p className="text-xs">æš‚æ— è§’è‰²</p></div> : currentCharacters.map((oc, index) => (
                                        <React.Fragment key={oc.id}>
                                            {ocDragMode && ocDropTarget === index && <div className="h-1 bg-amber-500 rounded-full mx-2 animate-pulse" />}
                                            <div draggable={ocDragMode} onDragStart={e => handleOcDragStart(e, index)} onDragOver={e => handleOcDragOver(e, index)} onDragEnd={handleOcDragEnd}
                                                className={`rounded-xl border transition-all ${ocDragMode && ocDragData?.index === index ? 'opacity-50' : ''} ${oc.enabled && ocEnabled ? 'bg-pink-500/10 border-pink-500/30' : 'bg-slate-800/50 border-slate-700/50'} ${ocDragMode ? 'cursor-grab' : ''}`}
                                                onMouseEnter={() => !ocDragMode && setHoveredOcId(oc.id)} onMouseLeave={() => setHoveredOcId(null)}>
                                                <div className="flex items-center gap-2 p-2">
                                                    {ocDragMode ? <GripVertical className="w-4 h-4 text-amber-400" /> : <button onClick={() => toggleOcEnabled(oc.id)} className={oc.enabled ? 'text-pink-400' : 'text-slate-600'}>{oc.enabled ? <CheckSquare className="w-4 h-4" /> : <Square className="w-4 h-4" />}</button>}
                                                    <div className="flex-1 min-w-0">
                                                        <div className="font-medium text-white text-sm truncate">{oc.name}</div>
                                                        <div className="text-[10px] text-slate-500 truncate">{oc.core?.slice(0, 25)}{oc.core?.length > 25 ? '...' : ''}</div>
                                                    </div>
                                                    {!ocDragMode && (
                                                        <div className="flex items-center gap-0.5">
                                                            <button onClick={() => editOc(oc)} className="p-1 text-slate-500 hover:text-blue-400"><Edit3 className="w-3.5 h-3.5" /></button>
                                                            <button onClick={() => deleteOc(oc.id)} className="p-1 text-slate-500 hover:text-red-400"><Trash2 className="w-3.5 h-3.5" /></button>
                                                        </div>
                                                    )}
                                                </div>
                                                {oc.outfits?.length > 0 && hoveredOcId === oc.id && !ocDragMode && (
                                                    <div className="px-2 pb-2">
                                                        <div className="text-[10px] text-slate-500 mb-1 flex items-center gap-1"><Shirt className="w-3 h-3" /> æœè£…</div>
                                                        <div className="space-y-1">
                                                            {oc.outfits.map(outfit => (
                                                                <div key={outfit.id} onClick={() => toggleOutfitInList(oc.id, outfit.id)} className={`flex items-center gap-1.5 px-2 py-1 rounded-lg cursor-pointer text-xs ${outfit.enabled ? 'bg-purple-500/20 text-purple-300 border border-purple-500/30' : 'bg-slate-800/50 text-slate-500 hover:bg-slate-800'}`}>
                                                                    {outfit.enabled ? <CheckSquare className="w-3 h-3" /> : <Square className="w-3 h-3" />}<span className="truncate">{outfit.name}</span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </React.Fragment>
                                    ))}
                                    {ocDragMode && currentCharacters.length > 0 && ocDropTarget === currentCharacters.length && <div className="h-1 bg-amber-500 rounded-full mx-2 animate-pulse" />}
                                </div>
                                <div className="p-2 border-t border-slate-800">
                                    <button onClick={createNewOc} className="w-full flex items-center justify-center gap-1.5 py-2 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-xl text-xs font-medium"><Plus className="w-3.5 h-3.5" /> æ·»åŠ è§’è‰²</button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* ç§»åŠ¨ç«¯ä¾§è¾¹æ é®ç½© */}
                    {isSidebarOpen && isMobile && <div className="fixed inset-0 bg-black/60 z-40" onClick={() => setIsSidebarOpen(false)} />}

                    {/* å³ä¾§ä¾§è¾¹æ  */}
                    <div className={`fixed top-0 right-0 h-full bg-slate-900 border-l border-slate-800 z-50 transform transition-transform duration-300 shadow-2xl flex flex-col w-full sm:w-[420px] ${isSidebarOpen ? 'translate-x-0' : 'translate-x-full'}`} onClick={e => e.stopPropagation()}>
                        <div className="flex border-b border-slate-800 bg-slate-950">
                            {[{ id: 'generate', icon: Sparkles }, { id: 'tools', icon: Wrench }, { id: 'export', icon: Database }, { id: 'history', icon: History }, { id: 'settings', icon: Plug }].map(tab => (
                                <button key={tab.id} onClick={() => setActiveSidebarTab(tab.id)} className={`flex-1 py-2 flex justify-center items-center text-xs font-medium ${activeSidebarTab === tab.id ? 'text-pink-500 border-b-2 border-pink-500' : 'text-slate-500 hover:text-slate-300'}`}><tab.icon className="w-4 h-4" /></button>
                            ))}
                        </div>
                        <div className="flex-1 overflow-y-auto custom-scrollbar p-3">
                            {/* ç”Ÿæˆ Tab */}
                            {activeSidebarTab === 'generate' && (
                                <div className="space-y-3">
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50">
                                        <h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><Sparkles className="w-3.5 h-3.5" /> AI æŠ½å¡é…ç½®</h3>
                                        <div className="mb-2 p-1.5 bg-slate-900/50 rounded-lg border border-indigo-500/20 text-[10px] flex items-center justify-between">
                                            <span className="text-indigo-300 flex items-center gap-1"><Server className="w-3 h-3" /> {API_PROVIDERS[apiProvider]?.name}</span>
                                            <span className="text-slate-500 truncate ml-2">{currentModel}</span>
                                        </div>
                                        {((ocEnabled && currentCharacters.filter(oc => oc.enabled).length > 0) || webSearchMode !== 'off') && (
                                            <div className="mb-2 flex gap-1.5">
                                                {ocEnabled && currentCharacters.filter(oc => oc.enabled).length > 0 && <div className="flex-1 p-1.5 bg-pink-500/10 rounded-lg border border-pink-500/20 text-[10px] flex items-center gap-1"><User className="w-3 h-3 text-pink-400" /><span className="text-pink-300 truncate">{currentCharacters.filter(oc => oc.enabled).map(oc => oc.name).join(', ')}</span></div>}
                                            </div>
                                        )}
                                        <div className="grid grid-cols-4 gap-1.5 mb-3">
                                            <div className="flex flex-col items-center gap-1"><span className="text-[9px] text-slate-500">é£æ ¼</span><button onClick={() => setGenerationMode(prev => prev === 'detailed' ? 'simple' : 'detailed')} className={`w-full py-1.5 rounded-lg text-[9px] font-medium ${generationMode === 'detailed' ? 'bg-gradient-to-r from-violet-600 to-pink-600 text-white' : 'bg-slate-700 text-slate-300'}`}>{generationMode === 'detailed' ? 'è¯¦ç»†' : 'ç²¾ç•¥'}</button></div>
                                            <div className="flex flex-col items-center gap-1"><span className="text-[9px] text-slate-500">è®°å¿†</span><div className="flex items-center gap-0.5 w-full"><button onClick={() => setKeepMemory(!keepMemory)} className={`flex-1 py-1.5 rounded-lg text-[9px] font-medium ${keepMemory ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300'}`}>{keepMemory ? 'å¼€' : 'å…³'}</button>{keepMemory && <button onClick={clearMemory} disabled={isSummarizing} className={`p-1 rounded-lg ${isSummarizing ? 'bg-emerald-500/30 text-emerald-400 animate-pulse' : 'bg-slate-700 text-slate-400 hover:text-red-400'}`}>{isSummarizing ? <Loader2 className="w-3 h-3 animate-spin" /> : <Trash2 className="w-3 h-3" />}</button>}</div></div>
                                            <div className="flex flex-col items-center gap-1"><span className="text-[9px] text-slate-500">ä¸ªæ€§åŒ–</span><div className="flex items-center gap-0.5 w-full"><button onClick={togglePersonalMode} className={`flex-1 py-1.5 rounded-lg text-[9px] font-medium ${personalMode === 'off' ? 'bg-slate-700 text-slate-300' : personalMode === 'summarize' ? 'bg-emerald-600 text-white' : 'bg-amber-600 text-white'}`}>{personalMode === 'off' ? 'å…³' : personalMode === 'summarize' ? 'æ€»ç»“' : 'å‘é€'}</button>{personalMode !== 'off' && <button onClick={() => setShowPreferencesModal(true)} className="p-1 bg-slate-700 text-slate-400 hover:text-blue-400 rounded-lg"><Search className="w-3 h-3" /></button>}</div></div>
                                            <div className="flex flex-col items-center gap-1"><span className="text-[9px] text-slate-500">è”ç½‘</span><div className="flex items-center gap-0.5 w-full"><button onClick={toggleWebSearchMode} className={`flex-1 py-1.5 rounded-lg text-[9px] font-medium ${webSearchMode === 'off' ? 'bg-slate-700 text-slate-300' : webSearchMode === 'on' ? 'bg-blue-600 text-white' : 'bg-amber-600 text-white'}`}>{webSearchMode === 'off' ? 'å…³' : webSearchMode === 'on' ? 'å¼€' : 'å‘é€'}</button>{webSearchMode !== 'off' && <button onClick={() => setShowWebSearchModal(true)} className="p-1 bg-slate-700 text-slate-400 hover:text-blue-400 rounded-lg"><Globe className="w-3 h-3" /></button>}</div></div>
                                        </div>
                                        {keepMemory && <p className="text-[9px] text-blue-400/70 mb-2 text-center">å·²è®°å½• {Math.floor(conversationHistory.length / 2)} è½®å¯¹è¯</p>}
                                        <div className="mb-2"><label className="block text-[10px] text-slate-400 mb-1">ä¸»é¢˜ (å¯é€‰)</label><input type="text" value={themeInput} onChange={e => setThemeInput(e.target.value)} placeholder="èµ›åšæœ‹å…‹, æ£®æ—ç²¾çµ..." className="w-full bg-slate-950 border border-slate-700 rounded-lg px-2.5 py-1.5 text-xs text-slate-200 focus:border-pink-500" /></div>
                                        <div className="mb-2">
                                            <button onClick={() => setShowPromptSettings(!showPromptSettings)} className="w-full flex items-center justify-between text-[10px] text-slate-400 hover:text-slate-200 bg-slate-800/50 hover:bg-slate-800 rounded-lg px-2.5 py-1.5"><div className="flex items-center gap-1.5"><PenLine className="w-3 h-3" /><span>é«˜çº§ï¼šæç¤ºè¯æ¨¡æ¿</span></div><ChevronRight className={`w-3 h-3 transition-transform ${showPromptSettings ? 'rotate-90' : ''}`} /></button>
                                            {showPromptSettings && (
                                                <div className="mt-2 space-y-2 bg-slate-950/50 rounded-lg p-2 border border-slate-800">
                                                    <div className="border-b border-slate-800 pb-2">
                                                        <div className="flex items-center gap-1">
                                                            <select value={currentPresetId || ''} onChange={e => e.target.value && loadPreset(e.target.value)} className="flex-1 bg-slate-800 border border-slate-700 rounded px-2 py-1 text-[10px] text-white"><option value="">é€‰æ‹©é¢„è®¾...</option>{promptPresets.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}</select>
                                                            {currentPresetId && <button onClick={updateCurrentPreset} className="p-1 bg-emerald-500/20 text-emerald-400 rounded"><Save className="w-3 h-3" /></button>}
                                                            <button onClick={() => setShowPresetNameInput(!showPresetNameInput)} className="p-1 bg-blue-500/20 text-blue-400 rounded"><Plus className="w-3 h-3" /></button>
                                                            {currentPresetId && <button onClick={() => deletePreset(currentPresetId)} className="p-1 bg-red-500/10 text-red-400 rounded"><Trash2 className="w-3 h-3" /></button>}
                                                        </div>
                                                        {showPresetNameInput && (
                                                            <div className="flex items-center gap-1 mt-1.5">
                                                                <input type="text" value={newPresetName} onChange={e => setNewPresetName(e.target.value)} placeholder="é¢„è®¾åç§°..." className="flex-1 bg-slate-900 border border-slate-600 rounded px-2 py-1 text-[10px] text-white" onKeyDown={e => { if (e.key === 'Enter') saveAsNewPreset(); }} autoFocus />
                                                                <button onClick={saveAsNewPreset} className="px-1.5 py-1 bg-blue-600 text-white rounded text-[10px]">å­˜</button>
                                                                <button onClick={() => setShowPresetNameInput(false)} className="p-1 text-slate-500"><X className="w-3 h-3" /></button>
                                                            </div>
                                                        )}
                                                    </div>
                                                    {!editingPromptPart && <div className="flex items-center justify-between"><span className="text-[10px] text-slate-400">ç‚¹å‡»è¾“å…¥æ¡†å¯å±•å¼€</span><button onClick={resetAllPromptParts} className="text-[10px] text-slate-500 hover:text-amber-400 flex items-center gap-0.5"><RotateCcw className="w-2.5 h-2.5" /> é‡ç½®</button></div>}
                                                    {[{ key: 'top', label: 'ğŸ”“ ç ´é™é¡¶éƒ¨' }, { key: 'main', label: 'ğŸ“‹ ä¸»æç¤ºè¯' }, { key: 'extra', label: 'âœ¨ é¢å¤–è¦æ±‚' }, { key: 'bottom', label: 'ğŸ”“ ç ´é™åº•éƒ¨' }].map(part => (
                                                        (!editingPromptPart || editingPromptPart === part.key) && (
                                                            <div key={part.key}>
                                                                <div className="flex items-center justify-between mb-0.5"><label className="text-[10px] font-medium text-slate-300">{part.label}</label><div className="flex items-center gap-1">{editingPromptPart === part.key && <button onClick={() => setEditingPromptPart(null)} className="text-[10px] text-blue-400 px-1.5 py-0.5 bg-blue-500/10 rounded">æ”¶èµ·</button>}<button onClick={() => resetPromptPart(part.key)} className="text-slate-600 hover:text-amber-400"><RotateCcw className="w-2.5 h-2.5" /></button></div></div>
                                                                <textarea value={promptParts[part.key]} onChange={e => updatePromptPart(part.key, e.target.value)} onFocus={() => setEditingPromptPart(part.key)} className={`w-full bg-slate-900 border border-slate-700 rounded p-1.5 text-[10px] text-slate-300 resize-none font-mono ${editingPromptPart === part.key ? 'h-48' : part.key === 'main' ? 'h-16' : 'h-12'}`} />
                                                            </div>
                                                        )
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                        <button onClick={handleGenerateText} disabled={isRolling} className="w-full py-2 rounded-lg bg-blue-600 hover:bg-blue-500 text-white text-xs font-medium disabled:opacity-50 mb-2">Step 1: ç”Ÿæˆæ–‡æœ¬</button>
                                        <div className="relative mb-2"><div className="absolute right-1.5 top-1.5 z-10"><button onClick={() => setGeneratedRawText('')} className="p-1 bg-slate-800/80 hover:bg-slate-700 text-slate-400 hover:text-red-400 rounded border border-slate-600/50"><Trash2 className="w-3 h-3" /></button></div><textarea value={generatedRawText} onChange={e => setGeneratedRawText(e.target.value)} placeholder="AI ç”Ÿæˆçš„æ–‡æœ¬..." className="w-full h-48 bg-slate-950 border border-slate-700 rounded-lg p-2 pr-10 text-[10px] text-slate-300 resize-none font-mono" /></div>
                                        <button onClick={() => handleParseAndFill()} disabled={isRolling} className="w-full py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-medium disabled:opacity-50">Step 2: åˆ†è¯å¡«å…¥</button>
                                    </div>
                                    <div className="relative flex items-center py-1"><div className="flex-grow border-t border-slate-700"></div><span className="px-3 text-slate-500 text-[10px]">æˆ–ç›´æ¥</span><div className="flex-grow border-t border-slate-700"></div></div>
                                    <button onClick={handleOneClickRoll} disabled={isRolling} className="w-full group relative overflow-hidden rounded-xl p-3 shadow-lg hover:shadow-pink-500/20"><div className={`absolute inset-0 opacity-90 group-hover:opacity-100 animate-gradient-x ${isNewbieMode ? 'bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-500' : 'bg-gradient-to-r from-violet-600 via-pink-600 to-orange-500'}`}></div><div className="relative flex items-center justify-center gap-2 text-white font-bold text-sm">{isRolling ? <Loader2 className="w-4 h-4 animate-spin" /> : <Play className="w-4 h-4 fill-white" />}ä¸€é”® AI æŠ½å¡</div></button>
                                </div>
                            )}
                            {/* å·¥å…· Tab */}
                            {activeSidebarTab === 'tools' && (
                                <div className="space-y-3">
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><Lock className="w-3.5 h-3.5" /> é”å®šæ§åˆ¶</h3><div className="grid grid-cols-2 gap-1.5"><button onClick={batchLockAll} className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-200 text-[10px]"><Shield className="w-3 h-3" /> å…¨éƒ¨é”å®š</button><button onClick={batchUnlockAll} className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-200 text-[10px]"><ShieldOff className="w-3 h-3" /> å…¨éƒ¨è§£é”</button></div></div>
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><CheckSquare className="w-3.5 h-3.5" /> å‹¾é€‰æ§åˆ¶</h3><div className="grid grid-cols-2 gap-1.5"><button onClick={batchIncludeAll} className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-slate-700 hover:bg-emerald-600 text-slate-200 text-[10px]"><CheckCircle2 className="w-3 h-3" /> å…¨éƒ¨å‹¾é€‰</button><button onClick={batchExcludeAll} className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-slate-700 hover:bg-red-500 text-slate-200 text-[10px]"><XCircle className="w-3 h-3" /> å…¨éƒ¨å–æ¶ˆ</button></div></div>
                                    {!isNewbieMode && <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><Scale className="w-3.5 h-3.5" /> æƒé‡ä¸å†…å®¹</h3><div className="space-y-1.5"><button onClick={batchClearWeights} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-slate-700 hover:bg-indigo-600 text-slate-200 text-[10px]"><Scale className="w-3 h-3" /> æ¸…é™¤æ‰€æœ‰æƒé‡</button><button onClick={batchClearAllContent} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg border border-red-500/20 bg-red-500/10 text-red-300 hover:bg-red-500/20 text-[10px]"><Eraser className="w-3 h-3" /> æ¸…ç©ºå†…å®¹ (ä¿ç•™é”å®š)</button></div></div>}
                                    {isNewbieMode && <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><Eraser className="w-3.5 h-3.5" /> å†…å®¹ç®¡ç†</h3><button onClick={batchClearAllContent} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg border border-red-500/20 bg-red-500/10 text-red-300 hover:bg-red-500/20 text-[10px]"><Eraser className="w-3 h-3" /> æ¸…ç©ºå†…å®¹ (ä¿ç•™é”å®š)</button></div>}
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><div className="flex justify-between items-center mb-2"><h3 className="text-xs font-bold text-slate-300 flex items-center gap-2"><ClipboardPaste className="w-3.5 h-3.5" /> æ™ºèƒ½è§£æ</h3><button onClick={() => setSmartPasteContent("")} className="text-slate-500 hover:text-red-400 p-1"><Trash2 className="w-3 h-3" /></button></div><textarea value={smartPasteContent} onChange={e => setSmartPasteContent(e.target.value)} placeholder="ç²˜è´´å®Œæ•´å’’è¯­ (tags)..." className="w-full h-20 bg-slate-900 border border-slate-700 rounded-lg p-2 text-[10px] text-slate-300 resize-none mb-2" /><button onClick={handleSmartPaste} disabled={isSmartParsing} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white text-[10px] font-medium disabled:opacity-50">{isSmartParsing ? <Loader2 className="w-3 h-3 animate-spin" /> : <BrainCircuit className="w-3 h-3" />}{isSmartParsing ? "è§£æä¸­..." : "æ™ºèƒ½è§£æå¡«å…¥"}</button></div>
                                </div>
                            )}
                            {/* å¯¼å…¥å¯¼å‡º Tab */}
                            {activeSidebarTab === 'export' && (
                                <div className="space-y-3">
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><FolderUp className="w-3.5 h-3.5" /> å…¨é‡å¤‡ä»½å¯¼å‡º</h3><div className="space-y-1 mb-3">{[{ key: 'apiConfig', label: 'API é…ç½®' }, { key: 'apiKeys', label: 'API Keys', warning: true }, { key: 'ocData', label: 'OC æ–‡ä»¶é›†' }, { key: 'promptParts', label: 'æç¤ºè¯æ¨¡æ¿' }, { key: 'promptPresets', label: 'æç¤ºè¯é¢„è®¾' }, { key: 'currentSlots', label: 'å½“å‰å¡æ§½' }].map(item => (<label key={item.key} className={`flex items-center gap-2 p-1.5 rounded-lg cursor-pointer text-[10px] ${exportOptions[item.key] ? 'bg-slate-700/50' : 'bg-slate-900/30 hover:bg-slate-800/50'}`}><input type="checkbox" checked={exportOptions[item.key]} onChange={e => setExportOptions(prev => ({ ...prev, [item.key]: e.target.checked }))} className="rounded border-slate-600 bg-slate-800 text-pink-500 w-3 h-3" /><span className={item.warning ? 'text-amber-400' : 'text-slate-200'}>{item.warning && <AlertTriangle className="w-3 h-3 inline mr-1" />}{item.label}</span></label>))}</div><button onClick={exportAllConfig} className="w-full flex items-center justify-center gap-1.5 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white font-medium text-xs"><Download className="w-3.5 h-3.5" /> å¯¼å‡ºå¤‡ä»½</button></div>
                                    <div className="bg-slate-800/50 rounded-xl p-3 border border-slate-700/50"><h3 className="text-xs font-bold text-slate-300 mb-2 flex items-center gap-2"><FolderDown className="w-3.5 h-3.5" /> å¯¼å…¥å¤‡ä»½</h3><div onClick={() => fileInputRef.current?.click()} className="border-2 border-dashed border-slate-700 hover:border-slate-500 rounded-xl p-6 text-center cursor-pointer group"><Upload className="w-8 h-8 mx-auto mb-2 text-slate-600 group-hover:text-slate-400" /><p className="text-xs text-slate-400">ç‚¹å‡»é€‰æ‹©å¤‡ä»½æ–‡ä»¶</p></div><input type="file" ref={fileInputRef} onChange={handleImportConfig} accept=".json" className="hidden" /></div>
                                    <div className="bg-red-500/10 rounded-xl p-3 border border-red-500/20"><h3 className="text-xs font-bold text-red-400 mb-2 flex items-center gap-2"><AlertTriangle className="w-3.5 h-3.5" /> å±é™©æ“ä½œ</h3><div className="space-y-1.5"><button onClick={clearAllCache} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg border border-amber-500/30 bg-amber-500/10 text-amber-400 hover:bg-amber-500/20 text-xs"><Database className="w-3.5 h-3.5" /> æ¸…é™¤æ‰€æœ‰ç¼“å­˜ï¼ˆå…ˆå¤‡ä»½ï¼‰</button><button onClick={resetAllSettings} className="w-full flex items-center justify-center gap-1.5 py-1.5 rounded-lg border border-red-500/30 bg-red-500/10 text-red-400 hover:bg-red-500/20 text-xs"><Trash2 className="w-3.5 h-3.5" /> é‡ç½®æ‰€æœ‰è®¾ç½®</button></div></div>
                                </div>
                            )}
                            {/* å†å² Tab */}
                            {activeSidebarTab === 'history' && (
                                <div className="space-y-1.5">
                                    {history.length === 0 ? <div className="flex flex-col items-center py-10 text-slate-600 border-2 border-dashed border-slate-800 rounded-xl"><History className="w-8 h-8 opacity-30" /><span className="text-xs mt-2">æš‚æ— å†å²è®°å½•</span></div> : history.map((entry, index) => ({ ...entry, originalIndex: index })).filter(e => e.source === 'ai').reverse().map(entry => {
                                        const isActive = entry.originalIndex === historyIndex;
                                        const tagCount = entry.data.mode === 'newbie' ? Object.values(entry.data.general || {}).reduce((a, s) => a + (s?.tags?.length || 0), 0) + Object.values(entry.data.characters || {}).reduce((a, s) => a + (s?.tags?.length || 0), 0) : Object.values(entry.data.slots || {}).reduce((a, s) => a + (s?.tags?.length || 0), 0);
                                        return (<div key={entry.id} onClick={() => jumpToHistory(entry.originalIndex)} className={`p-2 rounded-lg cursor-pointer border ${isActive ? "bg-blue-500/10 border-blue-500/50" : "bg-slate-800/40 border-slate-800 hover:bg-slate-800"}`}><div className="flex justify-between items-center mb-1"><span className={`text-[10px] font-mono font-medium ${isActive ? "text-blue-400" : "text-slate-500"}`}>{entry.timestamp}</span>{isActive && <span className="text-[9px] bg-blue-500/20 text-blue-300 px-1.5 py-0.5 rounded-full">å½“å‰</span>}</div><div className="text-[10px] text-slate-400">{tagCount} ä¸ªæç¤ºè¯</div></div>);
                                    })}
                                </div>
                            )}
                            {/* è®¾ç½® Tab */}
                            {activeSidebarTab === 'settings' && (
                                <div className="space-y-3">
                                    <div className={`rounded-xl p-3 border ${apiConnected ? 'bg-emerald-500/10 border-emerald-500/30' : 'bg-slate-800/50 border-slate-700/50'}`}><div className="flex items-center gap-2">{apiConnected ? <><div className="w-8 h-8 rounded-full bg-emerald-500/20 flex items-center justify-center"><PlugZap className="w-4 h-4 text-emerald-400" /></div><div><div className="text-xs font-medium text-emerald-400">å·²è¿æ¥</div><div className="text-[10px] text-emerald-400/70">{API_PROVIDERS[apiProvider]?.name}</div></div></> : <><div className="w-8 h-8 rounded-full bg-slate-800 flex items-center justify-center"><Plug className={`w-4 h-4 ${apiKeys[apiProvider] ? 'text-amber-400' : 'text-red-400'}`} /></div><div><div className={`text-xs font-medium ${apiKeys[apiProvider] ? 'text-amber-400' : 'text-red-400'}`}>{apiKeys[apiProvider] ? 'æœªæµ‹è¯•' : 'æœªé…ç½®'}</div><div className="text-[10px] text-slate-500">è¯·é…ç½®åæµ‹è¯•</div></div></>}</div></div>
                                    <div className="space-y-3"><h3 className="text-xs font-bold text-slate-200 flex items-center gap-2 border-b border-slate-800 pb-2"><Server className="w-3.5 h-3.5" /> API é…ç½®</h3><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase">æœåŠ¡å•†</label><select value={apiProvider} onChange={e => handleProviderChange(e.target.value)} className="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2.5 text-xs text-slate-200">{Object.values(API_PROVIDERS).map(p => <option key={p.id} value={p.id}>{p.name}</option>)}</select></div><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase flex items-center gap-1"><Globe className="w-3 h-3" /> Base URL</label><input type="text" value={currentBaseUrl} onChange={e => handleBaseUrlChange(e.target.value)} className="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2.5 text-xs text-slate-200 font-mono" /></div><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase">API Key</label><div className="relative"><KeyRound className="absolute left-2.5 top-2 w-3.5 h-3.5 text-slate-500" /><input type="password" value={apiKeys[apiProvider] || ''} onChange={e => handleApiKeyChange(e.target.value)} className="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 pl-8 pr-3 text-xs text-slate-200" placeholder="sk-..." /></div></div><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase flex items-center gap-1"><Cpu className="w-3 h-3" /> Model</label><div className="flex gap-1.5"><input type="text" value={currentModel} onChange={e => handleModelChange(e.target.value)} className="flex-1 bg-slate-950 border border-slate-700 rounded-lg py-2 px-2.5 text-xs text-slate-200 font-mono" /><button onClick={fetchModelList} disabled={isLoadingModels} className="px-2.5 py-2 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-lg text-slate-400 disabled:opacity-50">{isLoadingModels ? <Loader2 className="w-3.5 h-3.5 animate-spin" /> : <List className="w-3.5 h-3.5" />}</button></div>{availableModels.length > 0 && <div className="mt-1.5 max-h-40 overflow-y-auto custom-scrollbar bg-slate-950 border border-slate-700 rounded-lg">{availableModels.map(m => <button key={m} onClick={() => handleModelChange(m)} className={`w-full text-left px-2.5 py-1 text-[10px] font-mono hover:bg-slate-800 ${currentModel === m ? 'text-pink-400 bg-pink-500/10' : 'text-slate-400'}`}>{m}</button>)}</div>}</div><div className="grid grid-cols-2 gap-2"><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase">è¶…æ—¶ (ç§’)</label><input type="number" min="5" max="300" value={apiTimeout / 1000} onChange={e => setApiTimeout(Number(e.target.value) * 1000)} className="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2.5 text-xs text-slate-200" /></div><div><label className="block text-[10px] font-medium text-slate-400 mb-1 uppercase">æœ€å¤§é‡è¯•</label><input type="number" min="0" max="10" value={apiRetries} onChange={e => setApiRetries(Number(e.target.value))} className="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2.5 text-xs text-slate-200" /></div></div><button onClick={testApiConnection} disabled={isTestingConnection || !apiKeys[apiProvider]} className={`w-full flex items-center justify-center gap-1.5 py-2 rounded-lg font-medium text-xs disabled:opacity-50 ${apiConnected ? 'bg-emerald-600 hover:bg-emerald-500 text-white' : 'bg-slate-700 hover:bg-slate-600 text-slate-200'}`}>{isTestingConnection ? <><Loader2 className="w-3.5 h-3.5 animate-spin" /> æµ‹è¯•ä¸­...</> : <><TestTube className="w-3.5 h-3.5" /> æµ‹è¯•è¿æ¥</>}</button>{apiError && <div className="p-2 bg-red-500/10 border border-red-500/30 rounded-lg"><div className="flex items-start gap-1.5"><XCircle className="w-3.5 h-3.5 text-red-400 mt-0.5 flex-shrink-0" /><p className="text-[10px] text-red-400 break-all">{apiError}</p></div></div>}</div>
                                    <div className="space-y-3"><h3 className="text-xs font-bold text-slate-200 flex items-center gap-2 border-b border-slate-800 pb-2"><Settings2 className="w-3.5 h-3.5" /> æ¨¡å‹å‚æ•°</h3><div><div className="flex items-center justify-between mb-1"><label className="text-[10px] font-medium text-slate-400">æ¸©åº¦</label><span className="text-[10px] text-pink-400 font-mono">{temperature}</span></div><input type="range" min="0" max="2" step="0.05" value={temperature} onChange={e => setTemperature(parseFloat(e.target.value))} className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-pink-500" /></div><div><div className="flex items-center justify-between mb-1"><label className="text-[10px] font-medium text-slate-400">æ ¸é‡‡æ ·</label><span className="text-[10px] text-purple-400 font-mono">{topP}</span></div><input type="range" min="0" max="1" step="0.05" value={topP} onChange={e => setTopP(parseFloat(e.target.value))} className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-purple-500" /></div><div className="flex gap-1.5"><button onClick={() => { setTemperature(0.7); setTopP(0.9); }} className="flex-1 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-[10px]">ğŸ¯ ç²¾ç¡®</button><button onClick={() => { setTemperature(0.85); setTopP(0.9); }} className="flex-1 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-[10px]">âš–ï¸ å‡è¡¡</button><button onClick={() => { setTemperature(1.2); setTopP(0.95); }} className="flex-1 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg text-[10px]">ğŸ² åˆ›æ„</button></div></div>
                                    <div className="bg-gradient-to-r from-indigo-500/20 to-purple-500/20 border border-indigo-500/30 rounded-xl p-3 text-center space-y-2"><div><div className="text-[10px] text-indigo-300 font-medium">åŸé¡¹ç›®</div><div className="text-sm font-bold text-white">é€è¾°åä¸ƒ</div></div><div className="border-t border-indigo-500/20 pt-2"><div className="text-[10px] text-pink-300 font-medium">äºŒæ”¹ç‰ˆ</div><div className="text-sm font-bold text-white">æ¸Š//æ„¿</div></div></div>
                                    <a href="https://legend-patella-fdc.notion.site/2f8a533ab7a880ab8fa0df1e5bb051a6" target="_blank" rel="noopener noreferrer" className="block bg-gradient-to-r from-green-500/20 to-emerald-500/20 border border-green-500/30 rounded-xl p-3 text-center hover:from-green-500/30 hover:to-emerald-500/30"><div className="text-[10px] text-green-300 font-medium">å…è´¹æ•™ç¨‹</div><div className="text-sm font-bold text-white">æ•™ä½ å¦‚ä½•ç™½å«–API ğŸ</div></a>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Header */}
                    <header className="bg-slate-900/90 backdrop-blur-md border-b border-slate-800 sticky top-0 z-20 px-4 py-3 shadow-lg" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center">
                            <div className="flex items-center gap-3" style={{ marginLeft: isMobile ? 0 : (ocPanelOpen ? '288px' : '48px'), transition: 'margin-left 0.3s' }}>
                                <button onClick={() => setOcPanelOpen(!ocPanelOpen)} className={`p-2 rounded-lg md:hidden ${ocEnabled && currentCharacters.filter(oc => oc.enabled).length > 0 ? 'bg-pink-500/20 text-pink-400 border border-pink-500/30' : 'text-slate-400 hover:text-white hover:bg-slate-800'}`}><User className="w-5 h-5" /></button>
                                <div className={`p-2 rounded-lg shadow-lg ${isNewbieMode ? 'bg-gradient-to-tr from-purple-500 to-blue-600' : 'bg-gradient-to-tr from-pink-500 to-violet-600'}`}>{isNewbieMode ? <Code className="w-5 h-5 text-white" /> : <Sparkles className="w-5 h-5 text-white animate-pulse" />}</div>
                                <div className="relative">
                                    <button onClick={() => setShowModeDropdown(!showModeDropdown)} className="flex items-center gap-2 text-lg md:text-xl font-bold text-slate-200 hover:text-white">
                                        <span>{PROMPT_MODES[promptMode]?.name || 'SD æŠ½å¡'}</span>
                                        {promptMode === 'nai' && naiMultiMode && <span className="text-[10px] bg-amber-500/20 text-amber-400 px-1.5 py-0.5 rounded-full border border-amber-500/30">åˆ†è§’è‰²</span>}
                                        <ChevronDown className={`w-4 h-4 text-slate-400 transition-transform ${showModeDropdown ? 'rotate-180' : ''}`} />
                                    </button>
                                    <span className="text-slate-500 text-sm font-normal ml-1 hidden md:inline">{PROMPT_MODES[promptMode]?.fullName}</span>
                                    {showModeDropdown && (
                                        <div className="absolute top-full left-0 mt-2 bg-slate-800 border border-slate-700 rounded-xl shadow-2xl z-50 overflow-hidden min-w-[220px]">
                                            {Object.values(PROMPT_MODES).map(mode => {
                                                const ModeIcon = mode.icon;
                                                const isActive = promptMode === mode.id;
                                                return (
                                                    <div key={mode.id}>
                                                        <button onClick={() => switchPromptMode(mode.id)} className={`w-full flex items-center gap-3 px-4 py-3 text-left hover:bg-slate-700 ${isActive ? 'bg-blue-500/20 text-blue-400' : 'text-slate-300'}`}>
                                                            <div className={`w-8 h-8 rounded-lg flex items-center justify-center ${isActive ? 'bg-blue-500' : 'bg-slate-700'}`}><ModeIcon className="w-4 h-4 text-white" /></div>
                                                            <div><div className="font-medium">{mode.name}</div><div className="text-[10px] text-slate-500">{mode.fullName}</div></div>
                                                            {isActive && <CheckCircle2 className="w-4 h-4 ml-auto text-blue-400" />}
                                                        </button>
                                                        {mode.id === 'nai' && isActive && (
                                                            <div className="px-4 py-2 bg-slate-900/50 border-t border-slate-700/50">
                                                                <button onClick={e => { e.stopPropagation(); setNaiMultiMode(!naiMultiMode); showToast(naiMultiMode ? "å·²åˆ‡æ¢åˆ°å•äººæ¨¡å¼" : "å·²åˆ‡æ¢åˆ°åˆ†è§’è‰²æ¨¡å¼", "success"); }} className={`w-full flex items-center justify-between px-3 py-2 rounded-lg ${naiMultiMode ? 'bg-amber-500/20 border border-amber-500/30' : 'bg-slate-800 border border-slate-700'}`}>
                                                                    <div className="flex items-center gap-2"><Users className={`w-4 h-4 ${naiMultiMode ? 'text-amber-400' : 'text-slate-500'}`} /><span className={`text-xs font-medium ${naiMultiMode ? 'text-amber-300' : 'text-slate-400'}`}>åˆ†è§’è‰²æ¨¡å¼</span></div>
                                                                    <div className={`relative w-8 h-4 rounded-full ${naiMultiMode ? 'bg-amber-500' : 'bg-slate-600'}`}><div className={`absolute top-0.5 w-3 h-3 bg-white rounded-full transition-all ${naiMultiMode ? 'left-4' : 'left-0.5'}`} /></div>
                                                                </button>
                                                                <p className="text-[9px] text-slate-600 mt-1 px-1">{naiMultiMode ? 'ä½¿ç”¨ | åˆ†éš”å¤šè§’è‰²' : 'ä¼ ç»Ÿ9å®«æ ¼å¸ƒå±€'}</p>
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="fixed top-3 flex items-center gap-3 z-30" style={{ right: isMobile ? '16px' : '440px' }}>
                                <button onClick={copyAllPrompts} className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium text-sm border ${showCopyFeedback ? "bg-emerald-500/10 text-emerald-400 border-emerald-500/30" : "bg-slate-800 text-slate-300 hover:text-white hover:bg-slate-700 border-slate-700/50"}`}>{showCopyFeedback ? <CheckSquare className="w-4 h-4" /> : <Copy className="w-4 h-4" />}<span>{showCopyFeedback ? "å·²å¤åˆ¶" : isNewbieMode ? "å¤åˆ¶ XML" : isNaiMultiMode ? "å¤åˆ¶å’’è¯­" : "å¤åˆ¶å’’è¯­"}</span></button>
                                <button onClick={() => { setIsSidebarOpen(!isSidebarOpen); if (!isSidebarOpen) setActiveSidebarTab('generate'); }} className={`p-2 rounded-lg border ${isSidebarOpen ? "bg-slate-700 text-white border-slate-600" : "bg-transparent text-slate-400 hover:text-white hover:bg-slate-800 border-transparent"}`}><Menu className="w-5 h-5" /></button>
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <main className="p-4 md:p-6 transition-all" onClick={e => e.stopPropagation()}>
                        <div className="max-w-6xl mx-auto">
                            {!apiKeys[apiProvider] && <div onClick={() => { setIsSidebarOpen(true); setActiveSidebarTab('settings'); }} className="mb-6 text-center cursor-pointer group"><div className="inline-flex items-center gap-2 px-5 py-2.5 rounded-full bg-pink-500/10 text-pink-300 text-sm font-medium border border-pink-500/20 group-hover:bg-pink-500/20"><Settings2 className="w-4 h-4 animate-bounce" /><span>è¯·ç‚¹å‡»æ­¤å¤„é…ç½® API Key</span></div></div>}
                            {apiError && <div className="max-w-2xl mx-auto mb-6 bg-red-500/10 border border-red-500/50 text-red-200 px-4 py-3 rounded-lg text-center text-sm flex items-center justify-center gap-2"><AlertTriangle className="w-4 h-4" />{apiError}</div>}

                            {/* SD/NAI 9å®«æ ¼ */}
                            {!isNewbieMode && !isNaiMultiMode && (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
                                    {SLOT_CONFIG_STANDARD.map(config => {
                                        const slot = slots[config.id];
                                        if (!slot) return null;
                                        const SlotIcon = config.icon;
                                        return (
                                            <div key={config.id} className={`group flex flex-col rounded-xl border transition-all duration-300 overflow-hidden ${slot.locked ? "bg-slate-900 border-pink-500/40" : "bg-slate-900 border-slate-800 hover:border-slate-600"} ${!slot.included ? "opacity-60 grayscale-[0.5]" : ""}`}>
                                                <div onClick={() => setExpandedSlotId(config.id)} className="flex justify-between items-center px-4 py-3 bg-slate-900/50 border-b border-slate-800/50 cursor-pointer hover:bg-slate-800/80">
                                                    <div className="flex items-center gap-2 text-xs font-bold tracking-wider text-slate-400 uppercase"><SlotIcon className="w-3.5 h-3.5" />{config.label}</div>
                                                    <div className="flex items-center gap-1" onClick={e => e.stopPropagation()}>
                                                        <button onClick={() => setExpandedSlotId(config.id)} className="p-1.5 rounded text-slate-600 hover:text-white hover:bg-slate-800"><Maximize2 className="w-4 h-4" /></button>
                                                        <div className="w-px h-4 bg-slate-700 mx-1"></div>
                                                        <button onClick={() => copySlotContent(config.id)} className={`p-1.5 rounded ${slotCopyFeedback?.id === config.id ? "text-emerald-400 bg-emerald-400/10" : "text-slate-600 hover:text-emerald-400"}`}>{slotCopyFeedback?.id === config.id ? <CheckSquare className="w-4 h-4" /> : <Copy className="w-4 h-4" />}</button>
                                                        <button onClick={() => clearSlotTags(config.id)} className={`p-1.5 rounded ${slot.locked ? "text-slate-700 cursor-not-allowed" : "text-slate-600 hover:text-red-400"}`} disabled={slot.locked}><Trash2 className="w-4 h-4" /></button>
                                                        <div className="w-px h-4 bg-slate-700 mx-1"></div>
                                                        <button onClick={() => toggleInclude(config.id)} className={`p-1.5 rounded ${slot.included ? "text-emerald-400" : "text-slate-600"}`}>{slot.included ? <CheckSquare className="w-4 h-4" /> : <Square className="w-4 h-4" />}</button>
                                                        <button onClick={() => toggleLock(config.id)} className={`p-1.5 rounded ${slot.locked ? "text-pink-400 bg-pink-400/10" : "text-slate-600 hover:text-slate-300"}`}>{slot.locked ? <Lock className="w-4 h-4" /> : <Unlock className="w-4 h-4" />}</button>
                                                    </div>
                                                </div>
                                                <div className="relative flex-grow flex flex-col h-[240px]">
                                                    <div className={`flex-1 p-3 overflow-y-auto custom-scrollbar bg-slate-900/50 cursor-text ${dragData?.slotId === config.id ? 'bg-slate-800/30' : ''}`} ref={el => { if (!scrollRefs.current[config.id]) scrollRefs.current[config.id] = {}; scrollRefs.current[config.id].en = el; }} onScroll={() => handleSyncScroll(config.id, 'en')} onDragOver={handleDragOverContainer} onDrop={handleDrop} onClick={e => handleContainerClick(config.id, e)}>
                                                        <div className="flex flex-wrap gap-1.5 pointer-events-none">
                                                            {slot.tags.map((tag, index) => {
                                                                const isSelected = selectedTagIds.has(tag.id);
                                                                return (
                                                                    <React.Fragment key={tag.id}>
                                                                        {dropTarget?.slotId === config.id && dropTarget?.index === index && <div className="w-1 h-6 bg-pink-500 rounded-full animate-pulse" />}
                                                                        <div draggable onDragStart={e => handleDragStart(e, config.id, index)} onDragOver={e => handleDragOverTag(e, config.id, index)} onClick={e => handleTagClick(tag.id, e)} onDoubleClick={e => handleTagDoubleClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)}
                                                                            className={`group/tag flex items-center gap-1 px-2 py-1 rounded text-xs font-mono border transition-all select-none pointer-events-auto cursor-pointer ${editingTagId === tag.id ? "bg-slate-950 border-violet-500 ring-2 ring-violet-500/50" : isSelected ? "bg-indigo-600 border-indigo-400 text-white" : hoveredTagId === tag.id ? "bg-yellow-500/20 border-yellow-500/50 text-yellow-100" : "bg-slate-700 border-slate-500 text-slate-200"} ${dragData?.slotId === config.id && dragData?.index === index ? 'opacity-20' : ''}`}>
                                                                            <GripVertical className={`w-2.5 h-2.5 opacity-0 group-hover/tag:opacity-100 cursor-grab ${isSelected ? 'text-indigo-300' : 'text-slate-600'}`} />
                                                                            {editingTagId === tag.id ? <input ref={editInputRef} type="text" value={tag.en} onChange={e => updateTagText(config.id, tag.id, e.target.value)} onBlur={e => finishEditing(config.id, tag.id, e.target.value)} onKeyDown={e => { if (e.key === 'Enter') finishEditing(config.id, tag.id, e.currentTarget.value); }} onClick={e => e.stopPropagation()} className="bg-transparent text-white border-none p-0 min-w-[50px] outline-none" /> : <span>{tag.en}</span>}
                                                                            <button onClick={e => { e.stopPropagation(); removeTag(config.id, tag.id); }} className={`opacity-0 group-hover/tag:opacity-100 ml-0.5 ${isSelected ? 'text-indigo-200 hover:text-white' : 'hover:text-red-400'}`}><X className="w-3 h-3" /></button>
                                                                        </div>
                                                                    </React.Fragment>
                                                                );
                                                            })}
                                                            {dropTarget?.slotId === config.id && dropTarget?.index === slot.tags.length && <div className="w-1 h-6 bg-pink-500 rounded-full animate-pulse" />}
                                                            <div className="relative flex items-center min-w-[60px] flex-grow max-w-[120px] pointer-events-auto"><Plus className="w-3 h-3 text-slate-600 absolute left-1" /><input ref={el => slotInputRefs.current[config.id] = el} type="text" placeholder="Add..." className="w-full bg-transparent border-none text-xs text-slate-300 placeholder:text-slate-600 focus:ring-0 px-1 pl-5 py-1" onKeyDown={e => { if (e.key === 'Enter') { addTag(config.id, e.target.value); e.target.value = ''; } }} onBlur={e => { if (e.target.value) { addTag(config.id, e.target.value); e.target.value = ''; } }} /></div>
                                                        </div>
                                                    </div>
                                                    <div className="h-px bg-slate-800 w-full flex items-center justify-center"><div className="bg-slate-800 px-2 text-[10px] text-slate-600 uppercase font-bold">Translation</div></div>
                                                    <div className="h-[90px] shrink-0 p-3 bg-slate-950/30 overflow-y-auto custom-scrollbar" ref={el => { if (!scrollRefs.current[config.id]) scrollRefs.current[config.id] = {}; scrollRefs.current[config.id].zh = el; }} onScroll={() => handleSyncScroll(config.id, 'zh')}>
                                                        <div className="flex flex-wrap gap-1.5">
                                                            {slot.tags.map(tag => {
                                                                const isSelected = selectedTagIds.has(tag.id);
                                                                return (
                                                                    <div key={tag.id + '_zh'} onClick={e => handleTagClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)} className={`group/zhtag flex items-center gap-1 px-2 py-0.5 rounded text-xs border transition-all select-none cursor-pointer ${isSelected ? "bg-indigo-900/50 border-indigo-500/50 text-indigo-200" : hoveredTagId === tag.id ? "bg-yellow-500/20 border-yellow-500/50 text-yellow-200" : "bg-transparent border-transparent text-slate-500"}`}>
                                                                        <button onClick={e => { e.stopPropagation(); removeTag(config.id, tag.id); }} className="opacity-0 group-hover/zhtag:opacity-100 -ml-1 mr-1 p-0.5 text-slate-500 hover:text-red-400"><X className="w-3 h-3" /></button>
                                                                        <span>{tag.zh === '?' ? "..." : tag.zh}</span>
                                                                        <div className="flex flex-col gap-0.5 opacity-0 group-hover/zhtag:opacity-100 ml-1 -mr-1"><div onClick={e => { e.stopPropagation(); adjustTagWeight(config.id, tag.id, 0.1); }} className="h-2 w-2.5 bg-slate-800 border border-slate-600 hover:bg-emerald-500 flex items-center justify-center rounded-[1px] cursor-pointer text-slate-400 hover:text-white"><Plus className="w-1.5 h-1.5" /></div><div onClick={e => { e.stopPropagation(); adjustTagWeight(config.id, tag.id, -0.1); }} className="h-2 w-2.5 bg-slate-800 border border-slate-600 hover:bg-red-500 flex items-center justify-center rounded-[1px] cursor-pointer text-slate-400 hover:text-white"><Minus className="w-1.5 h-1.5" /></div></div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                    {isRolling && !slot.locked && <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-[1px] flex items-center justify-center z-10"><RefreshCw className="w-6 h-6 text-pink-500 animate-spin" /></div>}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}

                            {/* NewBie æ¨¡å¼ / NAI åˆ†è§’è‰²æ¨¡å¼ï¼ˆå…±ç”¨å¸ƒå±€ï¼‰*/}
                            {(isNewbieMode || isNaiMultiMode) && (
                                <div className="space-y-5">
                                    {/* é€šç”¨åŒºåŸŸ */}
                                    <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                                        {SLOT_CONFIG_NEWBIE_GENERAL.map(config => {
                                            const slot = isNaiMultiMode ? naiMultiBaseSlots[config.id] : newbieGeneralSlots[config.id];
                                            if (!slot) return null;
                                            const SlotIcon = config.icon;
                                            const categories = NEWBIE_CATEGORY_CONFIG[config.id] || [];
                                            const themeColor = isNaiMultiMode ? 'amber' : 'purple';
                                            return (
                                                <div key={config.id} className={`relative flex flex-col rounded-xl border transition-all duration-300 overflow-hidden h-[240px] ${slot.locked ? `bg-slate-900 border-${themeColor}-500/40` : "bg-slate-900 border-slate-800 hover:border-slate-600"} ${!slot.included ? "opacity-60 grayscale-[0.5]" : ""}`}>
                                                    <div className="flex justify-between items-center px-3 py-2.5 bg-slate-900/50 border-b border-slate-800/50 flex-shrink-0">
                                                        <div className="flex items-center gap-2 text-xs font-bold tracking-wider text-slate-400 uppercase"><SlotIcon className="w-3.5 h-3.5" />{config.label}</div>
                                                        <div className="flex items-center gap-1">
                                                            <button onClick={() => copySlotContent(config.id)} className={`p-1 rounded ${slotCopyFeedback?.id === config.id ? "text-emerald-400" : "text-slate-600 hover:text-emerald-400"}`}>{slotCopyFeedback?.id === config.id ? <CheckSquare className="w-3.5 h-3.5" /> : <Copy className="w-3.5 h-3.5" />}</button>
                                                            <button onClick={() => clearSlotTags(config.id)} className={`p-1 rounded ${slot.locked ? "text-slate-700 cursor-not-allowed" : "text-slate-600 hover:text-red-400"}`} disabled={slot.locked}><Trash2 className="w-3.5 h-3.5" /></button>
                                                            <button onClick={() => toggleInclude(config.id)} className={`p-1 rounded ${slot.included ? "text-emerald-400" : "text-slate-600"}`}>{slot.included ? <CheckSquare className="w-3.5 h-3.5" /> : <Square className="w-3.5 h-3.5" />}</button>
                                                            <button onClick={() => toggleLock(config.id)} className={`p-1 rounded ${slot.locked ? `text-${themeColor}-400 bg-${themeColor}-400/10` : "text-slate-600 hover:text-slate-300"}`}>{slot.locked ? <Lock className="w-3.5 h-3.5" /> : <Unlock className="w-3.5 h-3.5" />}</button>
                                                        </div>
                                                    </div>
                                                    <div className="flex-1 p-2.5 bg-slate-900/50 overflow-y-auto custom-scrollbar">
                                                        <div className="flex flex-wrap items-start gap-1.5 content-start">
                                                            {categories.map((cat, catIndex) => {
                                                                const catTags = slot.tags.filter(t => t.category === cat.id);
                                                                return (
                                                                    <React.Fragment key={cat.id}>
                                                                        {catIndex > 0 && <div className="category-separator h-6"></div>}
                                                                        {catTags.map(tag => (
                                                                            <div key={tag.id} onClick={e => handleTagClick(tag.id, e)} onDoubleClick={e => handleTagDoubleClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)} className={`group/tag flex items-center gap-1 px-2 py-1 rounded text-xs font-mono border transition-all select-none cursor-pointer ${editingTagId === tag.id ? "bg-slate-950 border-violet-500 ring-1 ring-violet-500/50" : selectedTagIds.has(tag.id) ? "bg-indigo-600 border-indigo-400 text-white" : hoveredTagId === tag.id ? "bg-yellow-500/20 border-yellow-500/50 text-yellow-100" : "bg-slate-800 border-slate-600 text-slate-300"}`}>
                                                                                {editingTagId === tag.id ? <input ref={editInputRef} type="text" value={tag.en} onChange={e => updateTagText(config.id, tag.id, e.target.value)} onBlur={e => finishEditing(config.id, tag.id, e.target.value)} onKeyDown={e => { if (e.key === 'Enter') finishEditing(config.id, tag.id, e.currentTarget.value); }} onClick={e => e.stopPropagation()} className="bg-transparent text-white border-none p-0 min-w-[50px] outline-none text-xs" /> : <span>{tag.en}</span>}
                                                                                <button onClick={e => { e.stopPropagation(); removeTag(config.id, tag.id); }} className="opacity-0 group-hover/tag:opacity-100 text-slate-500 hover:text-red-400"><X className="w-3 h-3" /></button>
                                                                            </div>
                                                                        ))}
                                                                        <button onClick={() => { const text = prompt(`æ·»åŠ  ${cat.label}:`); if (text) addTag(config.id, text, cat.id); }} className={`px-2 py-1 rounded text-xs font-mono bg-slate-800/50 border border-dashed border-slate-600 text-slate-500 hover:text-${themeColor}-400 hover:border-${themeColor}-400`}>{cat.label}[+]</button>
                                                                    </React.Fragment>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                    <div className="h-[70px] flex-shrink-0 p-2.5 bg-slate-950/30 border-t border-slate-800/50 overflow-y-auto custom-scrollbar">
                                                        <div className="flex flex-wrap gap-1.5">{slot.tags.map(tag => (<div key={tag.id + '_zh'} onClick={e => handleTagClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)} className={`group/zhtag flex items-center gap-1 text-xs px-2 py-0.5 rounded transition-colors cursor-pointer select-none ${selectedTagIds.has(tag.id) ? 'bg-indigo-900/50 border border-indigo-500/50 text-indigo-200' : hoveredTagId === tag.id ? 'bg-yellow-500/20 text-yellow-200' : 'text-slate-500 bg-slate-800/30'}`}><button onClick={e => { e.stopPropagation(); removeTag(config.id, tag.id); }} className="opacity-0 group-hover/zhtag:opacity-100 -ml-1 mr-0.5 text-slate-600 hover:text-red-400"><X className="w-3 h-3" /></button><span>{tag.zh === '?' ? '...' : tag.zh}</span></div>))}</div>
                                                    </div>
                                                    {isRolling && !slot.locked && <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-[1px] flex items-center justify-center z-10"><RefreshCw className={`w-5 h-5 text-${themeColor}-500 animate-spin`} /></div>}
                                                </div>
                                            );
                                        })}
                                    </div>

                                    {/* è§’è‰²åŒºåŸŸ */}
                                    <div className="bg-slate-900/50 rounded-xl border border-slate-800 p-4">
                                        <div className="flex items-center justify-between mb-4">
                                            <h3 className="text-sm font-bold text-slate-300 flex items-center gap-2">
                                                <Users className={`w-4 h-4 ${isNaiMultiMode ? 'text-amber-400' : 'text-pink-400'}`} />
                                                è§’è‰²åŒºåŸŸ
                                                <span className="text-[10px] text-slate-500 font-normal ml-2">ï¼ˆå·¦å³æ»‘åŠ¨ï¼‰</span>
                                            </h3>
                                            <div className="flex items-center gap-2 text-xs text-slate-500">
                                                <ChevronLeft className="w-4 h-4" />
                                                <span className="bg-slate-800 px-2 py-0.5 rounded-full">
                                                    {NEWBIE_CHARACTER_SLOTS.filter(c => ((isNaiMultiMode ? naiMultiCharSlots : newbieCharacterSlots)[c.id]?.tags || []).length > 0).length} / 4 è§’è‰²
                                                </span>
                                                <ChevronRight className="w-4 h-4" />
                                            </div>
                                        </div>
                                        
                                        <div className="character-scroll-container gap-4 pb-3" ref={characterScrollRef}>
                                            {NEWBIE_CHARACTER_SLOTS.map(charConfig => {
                                                const charSlot = isNaiMultiMode ? naiMultiCharSlots[charConfig.id] : newbieCharacterSlots[charConfig.id];
                                                if (!charSlot) return null;
                                                const categories = NEWBIE_CATEGORY_CONFIG.character;
                                                const hasContent = charSlot.tags.length > 0;
                                                const themeColor = isNaiMultiMode ? 'amber' : 'pink';
                                                
                                                return (
                                                    <div key={charConfig.id} 
                                                        className={`character-card relative flex flex-col rounded-xl border transition-all h-[620px] ${
                                                            hasContent 
                                                                ? `bg-slate-900 border-${themeColor}-500/30` 
                                                                : 'bg-slate-900/50 border-slate-800 border-dashed'
                                                        }`}>
                                                        
                                                        {/* è§’è‰²å¡ç‰‡å¤´éƒ¨ */}
                                                        <div className="flex justify-between items-center px-4 py-3 border-b border-slate-800/50 flex-shrink-0">
                                                            <div className="flex items-center gap-2">
                                                                <div className={`w-8 h-8 rounded-lg flex items-center justify-center ${
                                                                    hasContent 
                                                                        ? `bg-${themeColor}-500/20 border border-${themeColor}-500/30` 
                                                                        : 'bg-slate-800'
                                                                }`}>
                                                                    <User className={`w-4 h-4 ${hasContent ? `text-${themeColor}-400` : 'text-slate-600'}`} />
                                                                </div>
                                                                <div>
                                                                    <div className="text-sm font-bold text-slate-200">{charConfig.label}</div>
                                                                    <div className="text-[10px] text-slate-500">{charSlot.tags.length} ä¸ªæ ‡ç­¾</div>
                                                                </div>
                                                            </div>
                                                            <div className="flex items-center gap-1">
                                                                <button 
                                                                    onClick={() => copySlotContent(charConfig.id)} 
                                                                    className={`p-1.5 rounded-lg text-slate-600 hover:text-emerald-400 ${
                                                                        slotCopyFeedback?.id === charConfig.id ? 'text-emerald-400 bg-emerald-400/10' : ''
                                                                    }`}>
                                                                    {slotCopyFeedback?.id === charConfig.id 
                                                                        ? <CheckSquare className="w-4 h-4" /> 
                                                                        : <Copy className="w-4 h-4" />}
                                                                </button>
                                                                <button 
                                                                    onClick={() => clearSlotTags(charConfig.id)} 
                                                                    className="p-1.5 rounded-lg text-slate-600 hover:text-red-400">
                                                                    <Trash2 className="w-4 h-4" />
                                                                </button>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* TagsåŒºåŸŸ */}
                                                        <div className="flex-1 p-3 overflow-y-auto custom-scrollbar">
                                                            {hasContent ? (
                                                                <div className="flex flex-wrap items-start gap-1.5 content-start">
                                                                    {categories.map((cat, catIndex) => {
                                                                        const catTags = charSlot.tags.filter(t => t.category === cat.id);
                                                                        return (
                                                                            <React.Fragment key={cat.id}>
                                                                                {catIndex > 0 && <div className="category-separator h-6"></div>}
                                                                                {catTags.map(tag => (
                                                                                    <div 
                                                                                        key={tag.id}
                                                                                        onClick={e => handleTagClick(tag.id, e)}
                                                                                        onDoubleClick={e => handleTagDoubleClick(tag.id, e)}
                                                                                        onMouseEnter={() => setHoveredTagId(tag.id)}
                                                                                        onMouseLeave={() => setHoveredTagId(null)}
                                                                                        className={`group/tag flex items-center gap-1 px-2 py-1 rounded text-xs font-mono border transition-all select-none cursor-pointer ${
                                                                                            editingTagId === tag.id 
                                                                                                ? "bg-slate-950 border-violet-500 ring-1 ring-violet-500/50"
                                                                                                : selectedTagIds.has(tag.id) 
                                                                                                    ? "bg-indigo-600 border-indigo-400 text-white"
                                                                                                    : hoveredTagId === tag.id 
                                                                                                        ? "bg-yellow-500/20 border-yellow-500/50 text-yellow-100"
                                                                                                        : "bg-slate-800 border-slate-600 text-slate-300"
                                                                                        }`}>
                                                                                        {editingTagId === tag.id ? (
                                                                                            <input 
                                                                                                ref={editInputRef} 
                                                                                                type="text" 
                                                                                                value={tag.en}
                                                                                                onChange={e => updateTagText(charConfig.id, tag.id, e.target.value)}
                                                                                                onBlur={e => finishEditing(charConfig.id, tag.id, e.target.value)}
                                                                                                onKeyDown={e => { 
                                                                                                    if (e.key === 'Enter') finishEditing(charConfig.id, tag.id, e.currentTarget.value); 
                                                                                                }}
                                                                                                onClick={e => e.stopPropagation()}
                                                                                                className="bg-transparent text-white border-none p-0 min-w-[50px] outline-none text-xs" 
                                                                                            />
                                                                                        ) : (
                                                                                            <span>{tag.en}</span>
                                                                                        )}
                                                                                        <button 
                                                                                            onClick={e => { e.stopPropagation(); removeTag(charConfig.id, tag.id); }}
                                                                                            className="opacity-0 group-hover/tag:opacity-100 text-slate-500 hover:text-red-400">
                                                                                            <X className="w-3 h-3" />
                                                                                        </button>
                                                                                    </div>
                                                                                ))}
                                                                                <button 
                                                                                    onClick={() => {
                                                                                        const text = prompt(`æ·»åŠ  ${cat.label}:`);
                                                                                        if (text) addTag(charConfig.id, text, cat.id);
                                                                                    }}
                                                                                    className={`px-2 py-1 rounded text-xs font-mono bg-slate-800/50 border border-dashed border-slate-600 text-slate-500 hover:text-${themeColor}-400 hover:border-${themeColor}-400`}>
                                                                                    {cat.label}[+]
                                                                                </button>
                                                                            </React.Fragment>
                                                                        );
                                                                    })}
                                                                </div>
                                                            ) : (
                                                                <div className="flex flex-col items-center justify-center h-full text-slate-600">
                                                                    <div className="w-16 h-16 rounded-full bg-slate-800/50 flex items-center justify-center mb-4">
                                                                        <User className="w-8 h-8 opacity-30" />
                                                                    </div>
                                                                    <p className="text-sm font-medium mb-1">ç©ºè§’è‰²ä½</p>
                                                                    <p className="text-[10px] text-slate-700 mb-4">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ </p>
                                                                    <div className="flex flex-wrap justify-center gap-2">
                                                                        {categories.map(cat => (
                                                                            <button 
                                                                                key={cat.id} 
                                                                                onClick={() => {
                                                                                    const text = prompt(`æ·»åŠ  ${cat.label}:`);
                                                                                    if (text) addTag(charConfig.id, text, cat.id);
                                                                                }}
                                                                                className={`px-2.5 py-1.5 rounded-lg text-xs bg-slate-800/50 border border-dashed border-slate-700 text-slate-500 hover:text-${themeColor}-400 hover:border-${themeColor}-400`}>
                                                                                {cat.label}[+]
                                                                            </button>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* ç¿»è¯‘åŒºåŸŸ */}
                                                        <div className="h-[160px] flex-shrink-0 p-3 bg-slate-950/30 border-t border-slate-800/50 overflow-y-auto custom-scrollbar">
                                                            <div className="text-[10px] text-slate-600 uppercase font-bold tracking-wider mb-2">ç¿»è¯‘</div>
                                                            <div className="flex flex-wrap gap-1.5">
                                                                {charSlot.tags.length > 0 ? charSlot.tags.map(tag => (
                                                                    <div 
                                                                        key={tag.id + '_zh'} 
                                                                        onClick={e => handleTagClick(tag.id, e)}
                                                                        onMouseEnter={() => setHoveredTagId(tag.id)}
                                                                        onMouseLeave={() => setHoveredTagId(null)}
                                                                        className={`group/zhtag flex items-center gap-1 text-xs px-2 py-0.5 rounded transition-colors cursor-pointer select-none ${
                                                                            selectedTagIds.has(tag.id) 
                                                                                ? 'bg-indigo-900/50 border border-indigo-500/50 text-indigo-200'
                                                                                : hoveredTagId === tag.id 
                                                                                    ? 'bg-yellow-500/20 text-yellow-200' 
                                                                                    : 'text-slate-500 bg-slate-800/30'
                                                                        }`}>
                                                                        <button 
                                                                            onClick={e => { e.stopPropagation(); removeTag(charConfig.id, tag.id); }}
                                                                            className="opacity-0 group-hover/zhtag:opacity-100 -ml-1 mr-0.5 text-slate-600 hover:text-red-400">
                                                                            <X className="w-3 h-3" />
                                                                        </button>
                                                                        <span>{tag.zh === '?' ? '...' : tag.zh}</span>
                                                                    </div>
                                                                )) : (
                                                                    <span className="text-slate-700 text-xs">æš‚æ— ç¿»è¯‘</span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        
                                                        {/* åŠ è½½é®ç½© */}
                                                        {isRolling && (
                                                            <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-[1px] flex items-center justify-center z-10 rounded-xl">
                                                                <RefreshCw className={`w-6 h-6 text-${themeColor}-500 animate-spin`} />
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* å…¨å±ç¼–è¾‘å™¨å¼¹çª— (9å®«æ ¼) */}
                            {expandedSlotId && slots[expandedSlotId] && !isNewbieMode && !isNaiMultiMode && (
                                <div className="fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-4">
                                    <div className="w-full max-w-5xl h-[85vh] bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl flex flex-col overflow-hidden" onClick={e => e.stopPropagation()}>
                                        <div className="flex items-center justify-between px-5 py-3 bg-slate-900 border-b border-slate-800">
                                            <div className="flex items-center gap-3"><div className="bg-indigo-600/20 p-2 rounded-lg border border-indigo-500/30">{(() => { const C = SLOT_CONFIG_STANDARD.find(c => c.id === expandedSlotId); const Icon = C?.icon || Sparkles; return <Icon className="w-5 h-5 text-indigo-400" />; })()}</div><div><h2 className="text-lg font-bold text-white">{SLOT_CONFIG_STANDARD.find(c => c.id === expandedSlotId)?.label}</h2><p className="text-xs text-slate-500">èšç„¦æ¨¡å¼</p></div></div>
                                            <div className="flex gap-2"><button onClick={() => copySlotContent(expandedSlotId)} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white"><Copy className="w-5 h-5" /></button><button onClick={() => setExpandedSlotId(null)} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white"><X className="w-5 h-5" /></button></div>
                                        </div>
                                        <div className="flex-1 flex flex-col md:flex-row overflow-hidden">
                                            <div className="flex-1 flex flex-col border-r border-slate-800 min-w-0">
                                                <div className="p-2 bg-slate-900/50 border-b border-slate-800 text-xs font-bold text-slate-500 uppercase flex justify-between"><span>Tags</span><span className="bg-slate-800 px-1.5 rounded">{slots[expandedSlotId].tags.length}</span></div>
                                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3 bg-slate-900/30" onClick={e => handleContainerClick(expandedSlotId, e)}>
                                                    <div className="flex flex-wrap gap-1.5">
                                                        {slots[expandedSlotId].tags.map((tag, index) => {
                                                            const isSelected = selectedTagIds.has(tag.id);
                                                            return (
                                                                <React.Fragment key={tag.id}>
                                                                    {dropTarget?.slotId === expandedSlotId && dropTarget?.index === index && <div className="w-1 h-7 bg-pink-500 rounded-full animate-pulse" />}
                                                                    <div draggable onDragStart={e => handleDragStart(e, expandedSlotId, index)} onDragOver={e => handleDragOverTag(e, expandedSlotId, index)} onDrop={handleDrop} onClick={e => handleTagClick(tag.id, e)} onDoubleClick={e => handleTagDoubleClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)} className={`group/tag flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs font-mono border transition-all cursor-pointer select-none ${editingTagId === tag.id ? "bg-slate-950 border-violet-500 ring-2 ring-violet-500/50" : isSelected ? "bg-indigo-600 border-indigo-400 text-white shadow-lg scale-105" : hoveredTagId === tag.id ? "bg-yellow-500/20 border-yellow-500/50 text-yellow-100" : "bg-slate-800/50 border-slate-700 text-slate-300"}`}>
                                                                        <GripVertical className={`w-3 h-3 opacity-30 group-hover/tag:opacity-100 cursor-grab ${isSelected ? 'text-indigo-300' : 'text-slate-500'}`} />
                                                                        {editingTagId === tag.id ? <input ref={editInputRef} autoFocus type="text" value={tag.en} onChange={e => updateTagText(expandedSlotId, tag.id, e.target.value)} onBlur={e => finishEditing(expandedSlotId, tag.id, e.target.value)} onKeyDown={e => { if (e.key === 'Enter') finishEditing(expandedSlotId, tag.id, e.currentTarget.value); }} onClick={e => e.stopPropagation()} className="bg-transparent text-white border-none p-0 min-w-[60px] outline-none" /> : <span>{tag.en}</span>}
                                                                        <button onClick={e => { e.stopPropagation(); removeTag(expandedSlotId, tag.id); }} className={`ml-1 opacity-0 group-hover/tag:opacity-100 hover:text-red-400 ${isSelected ? "text-indigo-200" : "text-slate-500"}`}><X className="w-3 h-3" /></button>
                                                                    </div>
                                                                </React.Fragment>
                                                            );
                                                        })}
                                                        {dropTarget?.slotId === expandedSlotId && dropTarget?.index === slots[expandedSlotId].tags.length && <div className="w-1 h-7 bg-pink-500 rounded-full animate-pulse" />}
                                                        <div className="relative flex items-center min-w-[80px] max-w-[150px]"><Plus className="w-3.5 h-3.5 text-slate-600 absolute left-2" /><input ref={el => slotInputRefs.current[expandedSlotId] = el} type="text" placeholder="Add..." className="w-full bg-slate-800/30 border border-transparent hover:border-slate-700 focus:border-indigo-500 rounded-lg py-1.5 pl-7 text-xs text-slate-200" onKeyDown={e => { if (e.key === 'Enter') { addTag(expandedSlotId, e.target.value); e.target.value = ''; } }} onBlur={e => { if (e.target.value) { addTag(expandedSlotId, e.target.value); e.target.value = ''; } }} /></div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="flex-1 flex flex-col min-w-0 bg-slate-950/30">
                                                <div className="p-2 bg-slate-900/50 border-b border-slate-800 text-xs font-bold text-slate-500 uppercase">ç¿»è¯‘ & æƒé‡</div>
                                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3">
                                                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-1.5">
                                                        {slots[expandedSlotId].tags.map(tag => {
                                                            const isSelected = selectedTagIds.has(tag.id);
                                                            return (
                                                                <div key={tag.id + '_zh_exp'} onClick={e => handleTagClick(tag.id, e)} onMouseEnter={() => setHoveredTagId(tag.id)} onMouseLeave={() => setHoveredTagId(null)} className={`group flex items-center gap-2 p-2 rounded-lg border transition-all cursor-pointer ${isSelected ? "bg-indigo-900/30 border-indigo-500/50" : hoveredTagId === tag.id ? "bg-yellow-500/20 border-yellow-500/50" : "bg-slate-900/50 border-slate-800 hover:border-slate-700"}`}>
                                                                    <div className="flex-1 flex flex-col min-w-0"><span className={`text-[10px] font-mono truncate ${hoveredTagId === tag.id ? "text-yellow-200/70" : "text-slate-500"}`}>{tag.en}</span><span className={`text-xs font-medium truncate ${tag.zh === '?' ? "text-slate-600" : hoveredTagId === tag.id ? "text-yellow-100" : "text-slate-300"}`}>{tag.zh === '?' ? "æœªç¿»è¯‘" : tag.zh}</span></div>
                                                                    <button onClick={e => { e.stopPropagation(); removeTag(expandedSlotId, tag.id); }} className="opacity-0 group-hover:opacity-100 p-1 hover:bg-slate-800 hover:text-red-400 rounded text-slate-500 flex-shrink-0"><X className="w-3.5 h-3.5" /></button>
                                                                    <div className="flex items-center gap-0.5 bg-slate-950 rounded border border-slate-800 p-0.5 flex-shrink-0"><button onClick={e => { e.stopPropagation(); adjustTagWeight(expandedSlotId, tag.id, -0.1); }} className="p-1 hover:bg-slate-800 hover:text-red-400 rounded text-slate-500"><Minus className="w-3 h-3" /></button><div className="w-px h-3 bg-slate-800"></div><button onClick={e => { e.stopPropagation(); adjustTagWeight(expandedSlotId, tag.id, 0.1); }} className="p-1 hover:bg-slate-800 hover:text-emerald-400 rounded text-slate-500"><Plus className="w-3 h-3" /></button></div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </main>

                    {/* åº•éƒ¨æŒ‰é’® */}
                    <div className="fixed bottom-6 left-0 right-0 z-30 px-4 pointer-events-none" onClick={e => e.stopPropagation()}>
                        <div className="max-w-2xl mx-auto pointer-events-auto">
                            <div className={`flex gap-3 ${keepMemory && (lastTheme || conversationHistory.length > 0) ? '' : 'justify-center'}`}>
                                {keepMemory && (lastTheme || conversationHistory.length > 0) && (
                                    <button onClick={handleRegenerate} disabled={isRolling} className={`flex-1 group relative overflow-hidden rounded-2xl p-4 transition-all duration-200 shadow-2xl ${isRolling ? "scale-95 opacity-80" : "hover:scale-[1.02]"}`}>
                                        <div className={`absolute inset-0 opacity-90 group-hover:opacity-100 animate-gradient-x ${isNewbieMode ? 'bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-500' : 'bg-gradient-to-r from-violet-600 via-pink-600 to-orange-500'}`}></div>
                                        <div className="relative flex items-center justify-center gap-2 text-white font-bold text-sm md:text-lg uppercase">{isRolling ? <Loader2 className="w-5 h-5 animate-spin" /> : <RotateCw className="w-5 h-5" />}<span className="hidden sm:inline">é‡æ–°ç”Ÿæˆ</span><span className="sm:hidden">é‡æŠ½</span></div>
                                    </button>
                                )}
                                <button onClick={handleBottomButtonClick} disabled={isRolling} className={`group relative overflow-hidden rounded-2xl p-4 transition-all duration-200 shadow-2xl ${keepMemory && (lastTheme || conversationHistory.length > 0) ? 'flex-1' : 'w-full max-w-md'} ${isRolling ? "scale-95 opacity-80" : "hover:scale-[1.02]"}`}>
                                    <div className={`absolute inset-0 animate-gradient-x ${!apiKeys[apiProvider] ? 'bg-slate-800' : isNewbieMode ? 'bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-500' : 'bg-gradient-to-r from-violet-600 via-pink-600 to-orange-500'}`}></div>
                                    <div className="relative flex items-center justify-center gap-3 text-white font-bold text-sm md:text-lg uppercase">{isRolling ? <><RefreshCw className="w-5 h-5 animate-spin" /><span>{loadingText}</span></> : <>{isNewbieMode ? <Code className="w-5 h-5" /> : <Sparkles className="w-5 h-5 animate-pulse" />}<span>{!apiKeys[apiProvider] ? "è®¾ç½® API Key" : "ä¸€é”®æŠ½å¡"}</span></>}</div>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<StableDiffusionGacha />);
    </script>
</body>
</html>
